<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index · EquationLearning.jl Documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="home.html">EquationLearning.jl Documentation</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="home.html">Home</a></li><li><a class="tocitem" href="paper.html">VandenHeuvel et al. (2022)</a></li><li><a class="tocitem" href="tut.html">Tutorial</a></li><li><a class="tocitem" href="ref.html">Manual</a></li><li class="is-active"><a class="tocitem" href="index.html">Index</a><ul class="internal"><li><a class="tocitem" href="#basis_bootstrapping.jl"><span>basis_bootstrapping.jl</span></a></li><li><a class="tocitem" href="#bootstrapping.jl"><span>bootstrapping.jl</span></a></li><li><a class="tocitem" href="#comparison.jl"><span>comparison.jl</span></a></li><li><a class="tocitem" href="#gps.jl"><span>gps.jl</span></a></li><li><a class="tocitem" href="#optimisation.jl"><span>optimisation.jl</span></a></li><li><a class="tocitem" href="#pdes.jl"><span>pdes.jl</span></a></li><li><a class="tocitem" href="#plot_results.jl"><span>plot_results.jl</span></a></li><li><a class="tocitem" href="#synthetic_data.jl"><span>synthetic_data.jl</span></a></li><li><a class="tocitem" href="#utils.jl"><span>utils.jl</span></a></li><li><a class="tocitem" href="#Links"><span>Links</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="index.html">Index</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="index.html">Index</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/DanielVandH/EquationLearning.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h1><p>All the docstrings in this package are listed below. We separate the docstrings by file.</p><h2 id="basis_bootstrapping.jl"><a class="docs-heading-anchor" href="#basis_bootstrapping.jl">basis_bootstrapping.jl</a><a id="basis_bootstrapping.jl-1"></a><a class="docs-heading-anchor-permalink" href="#basis_bootstrapping.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.basis_bootstrap_gp-Union{Tuple{T1}, Tuple{T1, T1, T1, Vector{Function}, Vector{Function}, Vector{Function}, Vector{Function}}} where T1&lt;:(AbstractVector)" href="#EquationLearning.basis_bootstrap_gp-Union{Tuple{T1}, Tuple{T1, T1, T1, Vector{Function}, Vector{Function}, Vector{Function}, Vector{Function}}} where T1&lt;:(AbstractVector)"><code>EquationLearning.basis_bootstrap_gp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basis_bootstrap_gp(x::T1, t::T1, u::T1,
    D::Vector{Function}, D′::Vector{Function}, R::Vector{Function}, R′::Vector{Function};
    gp_setup::GP_Setup = GP_Setup(u),
    bootstrap_setup::Bootstrap_Setup = Bootstrap_Setup(x, t, u),
    optim_setup::Optim.Options = Optim.Options(),
    pde_setup::PDE_Setup = PDE_Setup(x),
    D_params = nothing, R_params = nothing, PDEkwargs...) where {T1&lt;:AbstractVector}</code></pre><p>Perform bootstrapping on the data <code>(x, t, u)</code> to learn the appropriate functional forms of  <code>(T, D, R)</code> with uncertainty, using the basis function approach.</p><p><strong>Arguments</strong></p><ul><li><code>x::T1</code>: The spatial data.</li><li><code>t::T1</code>: The temporal data.</li><li><code>u::T1</code>: The density data.</li><li><code>D::Vector{Function}</code>: The diffusion function, given in the form <code>D(u, β, D_params)</code>.</li><li><code>D′::Vector{Function}</code>: The derivative of the diffusion function, given in the form <code>D′(u, β, D_params)</code>.</li><li><code>R::Vector{Function}</code>: The reaction function, given in the form <code>R(u, γ, R_params)</code>.</li><li><code>R′::Vector{Function}</code>: The derivative of the reaction function, given in the form <code>R′(u, γ, R_params)</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>gp_setup::GP_Setup = GP_Setup(u)</code>: Defines the setup for the Gaussian process. See also <a href="ref.html#EquationLearning.GP_Setup"><code>GP_Setup</code></a>.</li><li><code>bootstart_setup::Bootstrap_Setup = Bootstrap_Setup(x, t, u)</code>: Defines some extra keyword arguments for the bootstrapping and optimisation process. See also <a href="ref.html#EquationLearning.Bootstrap_Setup"><code>Bootstrap_Setup</code></a>.</li><li><code>pde_setup::PDE_Setup = PDE_Setup(x)</code>: Defines some extra keyword arguments for the PDE solutions. See also <a href="ref.html#EquationLearning.PDE_Setup"><code>PDE_Setup</code></a>.</li><li><code>D_params = nothing</code>: Extra known parameters for the diffusion function <code>D</code>.</li><li><code>R_params = nothing</code>: Extra known parameters for the reaction function <code>R</code>.</li><li><code>PDEkwargs...</code>: Extra keyword arguments to use inside <code>DifferentialEquations.solve</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>bgp</code>: A <code>BasisBootResults</code> structure. See <a href="ref.html#EquationLearning.BasisBootResults"><code>BasisBootResults</code></a>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/basis_bootstrapping.jl#L177-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.basis_bootstrap_helper-NTuple{7, Any}" href="#EquationLearning.basis_bootstrap_helper-NTuple{7, Any}"><code>EquationLearning.basis_bootstrap_helper</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basis_bootstrap_helper(x, t, bootₓ, bootₜ, d, r, B)</code></pre><p>Computes all the required cache arrays and certain parameter values for the basis bootstrapping process. </p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The original spatial data. </li><li><code>t</code>: The original temporal data.</li><li><code>bootₓ</code>: The spatial bootstrapping grid.</li><li><code>bootₜ</code>: The temporal bootstrapping grid.</li><li><code>d</code>: Number of diffusion parameters. </li><li><code>r</code>: Number of reaction parameters.</li><li><code>B</code>: Number of bootstrap iterations being performed.</li></ul><p><strong>Outputs</strong></p><p>The outputs are broken into categories.</p><p><em>Bootstrapping computation</em>:</p><ul><li><code>x_min</code>: The minimum <code>x</code> value.</li><li><code>t_min</code>: The minimum <code>t</code> value.</li><li><code>x_rng</code>: The range of the <code>x</code> values, <code>x_max - x_min</code>.</li><li><code>t_rng</code>: The range of the <code>t</code> values, <code>t_max - t_min</code>.</li><li><code>Xₛ</code>: The test matrix for the bootstrapping grid data.</li></ul><p><em>Functions</em>:</p><ul><li><code>f</code>: Cache array for <code>f(x, t)</code>.</li><li><code>fₜ</code>: Cache array for <code>fₜ(x, t)</code>.</li><li><code>fₓ</code>: Cache array for <code>fₓ(x, t)</code>.</li><li><code>fₓₓ</code>: Cache array for <code>fₓₓ(x, t)</code>.</li><li><code>ffₜfₓfₓₓ</code>: Cache array for the stacked vector <code>[f; fₜ; fₓ; fₓₓ]</code>.</li><li><code>f_idx</code>: Indices for extracting <code>f(x, t)</code> from <code>ffₜfₓfₓₓ</code> from the random samples. </li><li><code>fₜ_idx</code>: Indices for extracting <code>fₜ(x, t)</code> from <code>ffₜfₓfₓₓ</code> from the random samples.</li><li><code>fₓ_idx</code>: Indices for extracting <code>fₓ(x, t)</code> from <code>ffₜfₓfₓₓ</code> from the random samples.</li><li><code>fₓₓ_idx</code>: Indices for extracting <code>fₓₓ(x, t)</code> from <code>ffₜfₓfₓₓ</code> from the random samples.</li></ul><p><em>Bases</em>:</p><ul><li><code>diffusionBases</code>: Matrix for storing the computed diffusion coefficients. Each column represents a set of parameters.</li><li><code>reactionBases</code>: Matrix for storing the computed reaction coefficients. Each column represents a set of parameters.</li></ul><p><em>Samples</em>:</p><ul><li><code>ℓz</code>: Cache array for storing the result of the matrix-vector product <code>Lz</code>, where <code>L</code> is the Cholesky factor and <code>z</code> is a random sample from <code>N(0, I)</code>.</li><li><code>zvals</code>: Matrix for storing the drawn <code>z</code> values from <code>N(0, I)</code>.</li></ul><p><em>Other caches</em></p><ul><li><code>Du</code>: Cache array for computing <code>D(u)</code>.</li><li><code>D′u</code>: Cache array for computing <code>D′(u)</code>.</li><li><code>Ru</code>: Cache array for computing <code>R(u)</code>.</li><li><code>R′u</code>: Cache array for computing <code>R′(u)</code>.</li><li><code>A</code>: Matrix for the linear system giving the coefficients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/basis_bootstrapping.jl#L35-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.basis_learn_equations!-NTuple{15, Any}" href="#EquationLearning.basis_learn_equations!-NTuple{15, Any}"><code>EquationLearning.basis_learn_equations!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basis_learn_equations!(f, fₜ, fₓ, fₓₓ, D, D′, R, 
    db, rb, d, r, A, 
    D_params, R_params, inIdx)</code></pre><p>Estimates the coefficients <code>db</code> and <code>rb</code> for diffusion and reaction.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Estimates for the learned function <code>f</code> of the reaction-diffusion process.</li><li><code>fₓ</code>: Derivatives of <code>f</code> in <code>x</code> at the same gridpoints.</li><li><code>fₓₓ</code>: Second derivatives of <code>f</code> in <code>x</code> at the same gridpoints.</li><li><code>fₜ</code>: Derivatives of <code>f</code> in <code>t</code> at the same gridpoints.</li><li><code>D</code>: The basis functions for the diffusion curve, provided as a vector of functions.</li><li><code>D′</code>: The derivatives for the basis functions <code>φ</code>, provided as a vector of functions. (These are <code>φ′ = d/du[φ(u)]</code>, so do not divide these by K.)</li><li><code>R</code>: The basis functions for the reaction curve, provided as a vector of functions.</li><li><code>db</code>: Cache array for the basis coefficients for diffusion.</li><li><code>rb</code>: Cache array for the basis coefficients for reaction.</li><li><code>d</code>: Number of diffusion parameters.</li><li><code>r</code>: Number of reaction parameters.</li><li><code>A</code>: Cache matrix for the coefficient matrix.</li><li><code>D_params</code>: Known diffusion parameters. </li><li><code>R_params</code>: Known reaction parameters.</li><li><code>inIdx</code>: Values to use. See <a href="index.html#EquationLearning.data_thresholder-Tuple{Any, Any, Any}"><code>data_thresholder</code></a>.</li></ul><p><strong>Outputs</strong></p><p><code>db</code> and <code>rb</code> are updated in-place with the diffusion and reaction coefficients, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/basis_bootstrapping.jl#L135-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.basis_sysdegeneral!-NTuple{4, Any}" href="#EquationLearning.basis_sysdegeneral!-NTuple{4, Any}"><code>EquationLearning.basis_sysdegeneral!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basis_sysdegeneral!(dudt, u, p, t)</code></pre><p>Function for computing the system of ODEs used in a discretised delay-reaction-diffusion PDE.</p><p><strong>Arguments</strong></p><ul><li><code>dudt</code>: A cache array used for storing the left-hand side of the system of ODEs. </li><li><code>u</code>: The current values for the variables in the systems.</li><li><code>p</code>: A tuple of parameters, given by:<ul><li><code>p[1] = N</code>: Number of mesh points being used for solving the PDE.</li><li><code>p[2] = V</code>: The volume of each cell in the discretised PDE.</li><li><code>p[3] = h</code>: The spacing between cells in the discretised PDE.</li><li><code>p[4] = a₀</code>: The coefficient on <code>u(a, t)</code> in the Robin boundary condition at <code>x = a</code> (the left end-point of the mesh). </li><li><code>p[5] = b₀</code>: The coefficient on <code>-∂u(a, t)/∂x</code> in the Robin boundary condition at <code>x = a</code> (the left end-point of the mesh).</li><li><code>p[6] = c₀</code>: The right-hand side constant in the Robin boundary condition at <code>x = a</code> (the left end-point of the mesh).</li><li><code>p[7] = a₁</code>: The coefficient on <code>u(b, t)</code> in the Robin boundary condition at <code>x = b</code> (the right end-point of the mesh). </li><li><code>p[8] = b₁</code>: The coefficient on <code>∂u(b, t)/∂t</code> in the Robin boundary condition at <code>x = b</code> (the right end-point of the mesh).</li><li><code>p[9] = c₁</code>: The right-hand side constant in the Robin boundary condition at <code>x = b</code> (the right end-point of the mesh).</li><li><code>p[10] = DD</code>: Cache array used for storing the values of the diffusion function <code>D</code> at <code>D(u)</code>.</li><li><code>p[11] = RR</code>: Cache array used for storing the values of the reaction function <code>R</code> at <code>R(u)</code>.</li><li><code>p[12] = DD′</code>: Cache array used for storing the values of the derivative of the diffusion function <code>D</code> at <code>D′(u)</code>.</li><li><code>p[13] = RR′</code>: Cache array used for storing the values of the derivative of the reaction function <code>R</code> at <code>R′(u)</code>.</li><li><code>p[14] = D</code>: The diffusion function, given in the form <code>D(u, β, D_params)</code>.</li><li><code>p[15] = R</code>: The reaction function, given in the form <code>R(u, γ, R_params)</code>.</li><li><code>p[16] = D′</code>: The derivative of the diffusion function, given in the form <code>D′(u, β, D_params)</code>.</li><li><code>p[17] = R′</code>: The derivative of the reaction function, given in the form <code>R′(u, γ, R_params)</code>.</li><li><code>p[18] = db</code>: The values of the diffusion parameters.</li><li><code>p[19] = rb</code>: The values of the reaction parameters.</li><li><code>p[20] = D_params</code>: Extra parameters used in the diffusion function.</li><li><code>p[21] = R_params</code>: Extra parameters for the reaction function.</li><li><code>p[22] = A₁</code>: A cache array used when computing the values of the diffusion function at a point u. Must be the same length as <code>meshPoints</code>.</li><li><code>p[23] = A₂</code>: A cache array used when computing the values of the reaction function at a point u. Must be the same length as <code>meshPoints</code>.</li></ul></li><li><code>t</code>: The current time value.</li></ul><p><strong>Outputs</strong></p><p>The values are updated in-place into the vector <code>dudt</code> for the new value of <code>dudt</code> at time <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/basis_bootstrapping.jl#L283-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.boot_pde_solve-Tuple{BasisBootResults, Any, Any, Any}" href="#EquationLearning.boot_pde_solve-Tuple{BasisBootResults, Any, Any, Any}"><code>EquationLearning.boot_pde_solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boot_pde_solve(bgp::BasisBootResults, x_pde, t_pde, u_pde, ICType = &quot;data&quot;)</code></pre><p>Solve the PDEs corresponding to the bootstrap iterates in <code>bgp</code> obtained from <a href="ref.html#EquationLearning.basis_bootstrap_gp"><code>basis_bootstrap_gp</code></a>. </p><p><strong>Arguments</strong></p><ul><li><code>bgp::BasisBootResults</code>: A <a href="ref.html#EquationLearning.BasisBootResults"><code>BasisBootResults</code></a> struct containing the results from <a href="ref.html#EquationLearning.basis_bootstrap_gp"><code>basis_bootstrap_gp</code></a>.</li><li><code>x_pde</code>: The spatial data to use for obtaining the initial condition.</li><li><code>t_pde</code>: The temporal data to use for obtaining the initial condition.</li><li><code>u_pde</code>: The density data to use for obtaining the initial condition.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ICType = &quot;data&quot;</code>: The type of initial condition to use. Should be either <code>&quot;data&quot;</code> or <code>&quot;gp&quot;</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>solns_all</code>: The solutions to the PDEs over the mesh points at each time value.</li></ul><p><strong>Note</strong></p><p>The <code>_pde</code> subscript is used to indicate that these data need not be the same as the <code>(x, t, u)</code> used in <a href="ref.html#EquationLearning.bootstrap_gp"><code>bootstrap_gp</code></a>, for example. For example, we may have 3 replicates of some data which we would easily use in <a href="ref.html#EquationLearning.bootstrap_gp"><code>bootstrap_gp</code></a>, but for the PDE we would need to average these  together for obtaining the solutions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/basis_bootstrapping.jl#L381-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.compute_valid_pde_indices-Tuple{Any, Any, Any, Any, BasisBootResults}" href="#EquationLearning.compute_valid_pde_indices-Tuple{Any, Any, Any, Any, BasisBootResults}"><code>EquationLearning.compute_valid_pde_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_valid_pde_indices(u_pde, num_t, num_u, nodes, weights, bgp::BasisBootResults)</code></pre><p>Method for calling [<code>compute_valid_pde_indices</code>] when providing only <code>bgp</code> and the data. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/basis_bootstrapping.jl#L372-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.compute_valid_pde_indices-Tuple{BasisBootResults, Any, Any, Any, Any, Any, Any, Any, Any, Any}" href="#EquationLearning.compute_valid_pde_indices-Tuple{BasisBootResults, Any, Any, Any, Any, Any, Any, Any, Any, Any}"><code>EquationLearning.compute_valid_pde_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_valid_pde_indices(bgp, u_pde, num_t, num_u, B, tr, dr, rr, nodes, weights, D_params, R_params, T_params)</code></pre><p>Computes the indices corresponding to the bootstrap samples which give valid PDE solutions. The check is done by  ensuring that the delay and diffusion values are strictly nonnegative, and the area under the reaction curve is nonnegative.</p><p><strong>Arguments</strong></p><ul><li><code>bgp::BasisBootResults</code>: The bootstrapping results.</li><li><code>u_pde</code>: The density data used for fitting the original Gaussian process. See also <a href="ref.html#EquationLearning.fit_GP"><code>fit_GP</code></a>.</li><li><code>num_u</code>: The number of density values to use for checking the validity of the diffusion function values.</li><li><code>B</code>: The number of bootstrap samples used.</li><li><code>dr</code>: The matrix of estimated diffusion parameters.</li><li><code>rr</code>: The matrix of estimated reaction parameters.</li><li><code>nodes</code>: Gauss-Legendre quadrature nodes.</li><li><code>weights</code>: Gauss-Legendre quadrature weights.</li><li><code>D_params</code>: Extra parameters for the diffusion function.</li><li><code>R_params</code>: Extra parameters for the reaction function. </li></ul><p><strong>Outputs</strong></p><ul><li><code>idx</code>: The vector of indices corresponding to valid bootstrap samples.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/basis_bootstrapping.jl#L334-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.curve_results-Tuple{BasisBootResults}" href="#EquationLearning.curve_results-Tuple{BasisBootResults}"><code>EquationLearning.curve_results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">curve_results(bgp::BasisBootResults; &lt;keyword arguments&gt;)</code></pre><p>Plots the learned functional forms along with confidence intervals for the bootstrapping results in <code>bgp</code> from the basis function approach.</p><p><strong>Arguments</strong></p><ul><li><code>bgp</code>: A <a href="ref.html#EquationLearning.BasisBootResults"><code>BasisBootResults</code></a> object which contains the results for the bootstrapping. </li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>level = 0.05</code>: The significance level for computing the credible intervals for the parameter values. </li><li><code>fontsize = 23</code>: Font size for the plots (to be used in <a href="@ref"><code>plot_aes!</code></a>).</li><li><code>x_scale = 1.0</code>: Value used for scaling the spatial data (and all other length units, e.g. for diffusion).</li><li><code>t_scale = 1.0</code>: Value used for scaling the temporal data (and all other time units, e.g. for reaction).</li></ul><p><strong>Outputs</strong></p><ul><li><code>diffusionCurvePlots</code>: A plot containing the learned functional form for the diffusion function, along with an uncertainty ribbon.</li><li><code>reactionCurvePlots</code>: A plot containing the learned functional form for the reaction function, along with an uncertainty ribbon.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/basis_bootstrapping.jl#L605-L622">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.curve_values-Tuple{BasisBootResults}" href="#EquationLearning.curve_values-Tuple{BasisBootResults}"><code>EquationLearning.curve_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">curve_values(bgp::BasisBootResults; &lt;keyword arguments&gt;)</code></pre><p>Computes values for plotting the learned functional forms along with confidence intervals for the bootstrapping results in <code>bgp</code> from the basis function approach.</p><p><strong>Arguments</strong></p><ul><li><code>bgp</code>: A <a href="ref.html#EquationLearning.BasisBootResults"><code>BasisBootResults</code></a> object which contains the results for the bootstrapping. </li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>level = 0.05</code>: The significance level for computing the credible intervals for the parameter values. </li><li><code>x_scale = 1.0</code>: Value used for scaling the spatial data (and all other length units, e.g. for diffusion).</li><li><code>t_scale = 1.0</code>: Value used for scaling the temporal data (and all other time units, e.g. for reaction).</li></ul><p><strong>Outputs</strong></p><ul><li><code>Du_vals</code>: Ribbon features for the diffusion functions.</li><li><code>Ru_vals</code>: Ribbon features for the reaction functions.</li><li><code>u_vals</code>: The density values used for computing the functions. </li><li><code>t_vals</code>: The time values used for computing the functions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/basis_bootstrapping.jl#L562-L580">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.density_results-Tuple{BasisBootResults}" href="#EquationLearning.density_results-Tuple{BasisBootResults}"><code>EquationLearning.density_results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">density_results(bgp::BasisBootResults; &lt;keyword arguments&gt;)</code></pre><p>Plots the densities for the bootstrapping results in <code>bgp</code> with the basis function approach.</p><p><strong>Arguments</strong></p><ul><li><code>bgp</code>: A <a href="ref.html#EquationLearning.BasisBootResults"><code>BasisBootResults</code></a> object which contains the results for the bootstrapping. </li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>level = 0.05</code>: The significance level for computing the credible intervals for the parameter values. </li><li><code>fontsize = 23</code>: Font size for the plots (to be used in <a href="@ref"><code>plot_aes!</code></a>).</li><li><code>diffusion_scales = nothing</code>: Values that multiply the individual diffusion parameters. </li><li><code>reaction_scales = nothing</code>: Values that multiply the individual reaction parameters.</li><li><code>diffusion_resolution = (800, 800)</code>: Resolution for the diffusion figure.</li><li><code>reaction_resolution = (800, 800)</code>: Resolution for the reaction figure.</li></ul><p><strong>Outputs</strong></p><ul><li><code>diffusionDensityFigure</code>: A figure of plots containing a density plot for each diffusion parameter.</li><li><code>reactionDensityFigure</code>: A figure of plots containing a density plot for each reaction parameter.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/basis_bootstrapping.jl#L504-L523">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.density_values-Tuple{BasisBootResults}" href="#EquationLearning.density_values-Tuple{BasisBootResults}"><code>EquationLearning.density_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">density_values(bgp::BasisBootResults; &lt;keyword arguments&gt;)</code></pre><p>Computes the densities for the bootstrapping results in <code>bgp</code> from a basis function approach.</p><p><strong>Arguments</strong></p><ul><li><code>bgp</code>: A <a href="ref.html#EquationLearning.BasisBootResults"><code>BasisBootResults</code></a> object which contains the results for the bootstrapping. </li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>level = 0.05</code>: The significance level for computing the credible intervals for the parameter values. </li><li><code>fontsize = 23</code>: Font size for the plots (to be used in <a href="@ref"><code>plot_aes!</code></a>).</li><li><code>diffusion_scales = nothing</code>: Values that multiply the individual diffusion parameters. </li><li><code>reaction_scales = nothing</code>: Values that multiply the individual reaction parameters.</li></ul><p><strong>Outputs</strong></p><ul><li><code>dr</code>: Diffusion densities. </li><li><code>rr</code>: Reaction densities. </li><li><code>d</code>: Number of diffusion parameters.</li><li><code>r</code>: Number of reaction parameters. </li><li><code>delayCIs</code>: Confidence intervals for the delay parameters. </li><li><code>diffusionCIs</code>: Confidence intervals for the diffusion parameters. </li><li><code>reactionCIS</code>: Confidence intervals for the reaction parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/basis_bootstrapping.jl#L447-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.evaluate_basis!-NTuple{6, Any}" href="#EquationLearning.evaluate_basis!-NTuple{6, Any}"><code>EquationLearning.evaluate_basis!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluate_basis!(val, coefficients, basis, point, A)</code></pre><p>Evaluates the function <code>func(u) = ∑_(i=1)^n coefficients[i]basis[i](u)</code> at the point u = <code>point</code> and puts it into <code>val</code>. This function differs from <code>evaluateBasis</code> as it works directly on vectors and uses matrix multiplication rather than dot products (although they are equivalent). The function uses <code>@inline</code> to suggest that the compiler could inline this in the LLVM.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/basis_bootstrapping.jl#L19-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.evaluate_basis-NTuple{4, Any}" href="#EquationLearning.evaluate_basis-NTuple{4, Any}"><code>EquationLearning.evaluate_basis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluate_basis(coefficients, basis, point)</code></pre><p>Evaluates the function <code>func(u) = ∑_(i=1)^n coefficients[i]basis[i](u)</code> at the point u = <code>point</code>.  The function uses <code>@inline</code> to suggest that the compiler could inline this in the LLVM.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/basis_bootstrapping.jl#L9-L14">source</a></section></article><h2 id="bootstrapping.jl"><a class="docs-heading-anchor" href="#bootstrapping.jl">bootstrapping.jl</a><a id="bootstrapping.jl-1"></a><a class="docs-heading-anchor-permalink" href="#bootstrapping.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.bootstrap_gp-Union{Tuple{T1}, Tuple{T1, T1, T1, Function, Function, Function, Function, Function, T1, T1, T1, T1, T1}} where T1&lt;:(AbstractVector)" href="#EquationLearning.bootstrap_gp-Union{Tuple{T1}, Tuple{T1, T1, T1, Function, Function, Function, Function, Function, T1, T1, T1, T1, T1}} where T1&lt;:(AbstractVector)"><code>EquationLearning.bootstrap_gp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bootstrap_gp(x::T1, t::T1, u::T1,
    T::Function, D::Function, D′::Function, R::Function,
    α₀::T1, β₀::T1, γ₀::T1, lowers::T1, uppers::T1;
    gp_setup::GP_Setup = GP_Setup(u),
    bootstrap_setup::Bootstrap_Setup = Bootstrap_Setup(x, t, u),
    optim_setup::Optim.Options = Optim.Options(),
    pde_setup::PDE_Setup = PDE_Setup(x),
    D_params = nothing, R_params = nothing, T_params = nothing, zvals = nothing, PDEkwargs...) where {T1&lt;:AbstractVector}</code></pre><p>Perform bootstrapping on the data <code>(x, t, u)</code> to learn the appropriate functional forms of  <code>(T, D, R)</code> with uncertainty. </p><p><strong>Arguments</strong></p><ul><li><code>x::T1</code>: The spatial data.</li><li><code>t::T1</code>: The temporal data.</li><li><code>u::T1</code>: The density data.</li><li><code>T::Function: The delay function, given in the form</code>T(t, α, T_params)`.</li><li><code>D::Function</code>: The diffusion function, given in the form <code>D(u, β, D_params)</code>.</li><li><code>D′::Function</code>: The derivative of the diffusion function, given in the form <code>D′(u, β, D_params)</code>.</li><li><code>R::Function</code>: The reaction function, given in the form <code>R(u, γ, R_params)</code>.</li><li><code>R′::Function</code>: The derivative of the reaction function, given in the form <code>R′(u, γ, R_params)</code>.</li><li><code>α₀::T1</code>: Initial estimates of the delay parameters. Not actually used for anything other than ensuring the functions are specified correctly.</li><li><code>β₀::T1</code>: Initial estimates of the diffusion parameters. Not actually used for anything other than ensuring the functions are specified correctly. </li><li><code>γ₀::T1</code>: Initial estimates of the reaction parameters. Not actually used for anything other than ensuring the functions are specified correctly. </li><li><code>lowers::T1</code>: Lower bounds to use for constructing the Latin hypersquare design, and for the constrained problem if <code>constrained = true</code> in <code>bootstrap_setup</code>.</li><li><code>uppers::T1</code>: Upper bounds to use for constructing the Latin hypersquare design, and for the constrained problem if <code>constrained = true</code> in <code>bootstrap_setup</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>gp_setup::GP_Setup = GP_Setup(u)</code>: Defines the setup for the Gaussian process. See also <a href="ref.html#EquationLearning.GP_Setup"><code>GP_Setup</code></a>.</li><li><code>bootstart_setup::Bootstrap_Setup = Bootstrap_Setup(x, t, u)</code>: Defines some extra keyword arguments for the bootstrapping and optimisation process. See also <a href="ref.html#EquationLearning.Bootstrap_Setup"><code>Bootstrap_Setup</code></a>.</li><li><code>optim_setup::Optim.Options = Optim_Options()</code>: Defines some options when using <code>Optim.optimize</code>.</li><li><code>pde_setup::PDE_Setup = PDE_Setup(x)</code>: Defines some extra keyword arguments for the PDE solutions. See also <a href="ref.html#EquationLearning.PDE_Setup"><code>PDE_Setup</code></a>.</li><li><code>D_params = nothing</code>: Extra known parameters for the diffusion function <code>D</code>.</li><li><code>R_params = nothing</code>: Extra known parameters for the reaction function <code>R</code>.</li><li><code>T_params = nothing</code>: Extra known parameters for the delay function <code>T</code>.</li><li><code>PDEkwargs...</code>: Extra keyword arguments to use inside <code>DifferentialEquations.solve</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>bgp</code>: A <code>BootResults</code> structure. See <a href="ref.html#EquationLearning.BootResults"><code>BootResults</code></a>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/bootstrapping.jl#L324-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.bootstrap_grid-NTuple{4, Any}" href="#EquationLearning.bootstrap_grid-NTuple{4, Any}"><code>EquationLearning.bootstrap_grid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bootstrap_grid(x, t, bootₓ, bootₜ)</code></pre><p>Computes the grid used for bootstrapping. See also <a href="index.html#EquationLearning.bootstrap_helper-NTuple{16, Any}"><code>bootstrap_helper</code></a> and <a href="ref.html#EquationLearning.bootstrap_gp"><code>bootstrap_gp</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The original spatial data. </li><li><code>t</code>: The original temporal data.</li><li><code>bootₓ</code>: The spatial bootstrapping grid.</li><li><code>bootₜ</code>: The temporal bootstrapping grid.</li></ul><p><strong>Outputs</strong></p><ul><li><code>x_min</code>: The minimum <code>x</code> value.</li><li><code>x_max</code>: The maximum <code>x</code> value.</li><li><code>t_min</code>: The minimum <code>t</code> value.</li><li><code>t_max</code>: The maximum <code>t</code> value.</li><li><code>x_rng</code>: The range of the <code>x</code> values, <code>x_max - x_min</code>.</li><li><code>t_rng</code>: The range of the <code>t</code> values, <code>t_max - t_min</code>.</li><li><code>Xₛ</code>: The test matrix for the bootstrapping grid data.</li><li><code>unscaled_t̃</code>: The unscaled <code>t</code> values for the bootstrapping grid. Used for computing the loss function later.</li><li><code>nₓnₜ</code>: The number of test data points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/bootstrapping.jl#L9-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.bootstrap_helper-NTuple{16, Any}" href="#EquationLearning.bootstrap_helper-NTuple{16, Any}"><code>EquationLearning.bootstrap_helper</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bootstrap_helper(x, t, bootₓ, bootₜ, α₀, β₀, γ₀, B, num_restarts, meshPoints, δt, finalTime, gp, lowers, uppers)</code></pre><p>Computes all the required cache arrays and certain parameter values for the bootstrapping process.  The function simply calls <a href="index.html#EquationLearning.bootstrap_grid-NTuple{4, Any}"><code>bootstrap_grid</code></a>, <a href="index.html#EquationLearning.preallocate_bootstrap-NTuple{6, Any}"><code>preallocate_bootstrap</code></a>, and <a href="index.html#EquationLearning.preallocate_eqlearn-NTuple{12, Any}"><code>preallocate_eqlearn</code></a>. See also  <a href="ref.html#EquationLearning.bootstrap_gp"><code>bootstrap_gp</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The original spatial data. </li><li><code>t</code>: The original temporal data.</li><li><code>bootₓ</code>: The spatial bootstrapping grid.</li><li><code>bootₜ</code>: The temporal bootstrapping grid.</li><li><code>α₀</code>: Initial values for the delay coefficients. (Not actually used anywhere other than for computing the number of delay parameters and checking arguments.)</li><li><code>β₀</code>: Initial values for the diffusion coefficients. (Not actually used anywhere other than for computing the number of diffusion parameters and checking arguments.)</li><li><code>γ₀</code>: Initial values for the reaction coefficients. (Not actually used anywhere other than for computing the number of reaction parameters and checking arguments.)</li><li><code>B</code>: Number of bootstrap iterations being performed.</li><li><code>num_restarts</code>: Number of times to restart the optimisation problem when solving the nonlinear least squares problems. See <a href="index.html#EquationLearning.learn_equations!-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Vararg{Any}}"><code>learn_equations!</code></a>.</li><li><code>meshPoints</code>: The spatial mesh used for solving the PDEs.</li><li><code>δt</code>: A number or a vector specifying the spacing between returned times for the solutions to the PDEs or specific times, respectively.</li><li><code>finalTime</code>: The final time to give the solution to the PDEs at.</li><li><code>gp</code>: The fitted Gaussian process. See <a href="ref.html#EquationLearning.fit_GP"><code>fit_GP</code></a>.</li><li><code>lowers</code>: Lower bounds for the delay, diffusion, and reaction parameters (in that order) for constructing the Latin hypercube design (only for the grid, these do not constrain the parameter values).</li><li><code>uppers</code>: Upper bounds for the delay, diffusion, and reaction parameters (in that order) for constructing the Latin hypercube design (only for the grid, these do not constrain the parameter values).</li></ul><p><strong>Outputs</strong></p><p>The outputs are broken into categories.</p><p><em>Bootstrapping computation</em>:</p><ul><li><code>x_min</code>: The minimum <code>x</code> value.</li><li><code>x_max</code>: The maximum <code>x</code> value.</li><li><code>t_min</code>: The minimum <code>t</code> value.</li><li><code>t_max</code>: The maximum <code>t</code> value.</li><li><code>x_rng</code>: The range of the <code>x</code> values, <code>x_max - x_min</code>.</li><li><code>t_rng</code>: The range of the <code>t</code> values, <code>t_max - t_min</code>.</li><li><code>Xₛ</code>: The test matrix for the bootstrapping grid data.</li><li><code>unscaled_t̃</code>: The unscaled <code>t</code> values for the bootstrapping grid. Used for computing the delay function in the loss function.</li><li><code>nₓnₜ</code>: The number of test data points.</li></ul><p><em>Functions</em>:</p><ul><li><code>f</code>: Cache array for <code>f(x, t)</code>.</li><li><code>fₜ</code>: Cache array for <code>fₜ(x, t)</code>.</li><li><code>fₓ</code>: Cache array for <code>fₓ(x, t)</code>.</li><li><code>fₓₓ</code>: Cache array for <code>fₓₓ(x, t)</code>.</li><li><code>ffₜfₓfₓₓ</code>: Cache array for the stacked vector <code>[f; fₜ; fₓ; fₓₓ]</code>.</li><li><code>f_idx</code>: Indices for extracting <code>f(x, t)</code> from <code>ffₜfₓfₓₓ</code> from the random samples. </li><li><code>fₜ_idx</code>: Indices for extracting <code>fₜ(x, t)</code> from <code>ffₜfₓfₓₓ</code> from the random samples.</li><li><code>fₓ_idx</code>: Indices for extracting <code>fₓ(x, t)</code> from <code>ffₜfₓfₓₓ</code> from the random samples.</li><li><code>fₓₓ_idx</code>: Indices for extracting <code>fₓₓ(x, t)</code> from <code>ffₜfₓfₓₓ</code> from the random samples.</li></ul><p><em>Bases</em>:</p><ul><li><code>tt</code>: Number of delay parameters.</li><li><code>d</code>: Number of diffusion parameters.</li><li><code>r</code>: Number of reaction parameters.</li><li><code>delayBases</code>: Matrix for storing the computed delay coefficients. Each column represents a set of parameters.</li><li><code>diffusionBases</code>: Matrix for storing the computed diffusion coefficients. Each column represents a set of parameters.</li><li><code>reactionBases</code>: Matrix for storing the computed reaction coefficients. Each column represents a set of parameters.</li></ul><p><em>Samples</em>:</p><ul><li><code>ℓz</code>: Cache array for storing the result of the matrix-vector product <code>Lz</code>, where <code>L</code> is the Cholesky factor and <code>z</code> is a random sample from <code>N(0, I)</code>.</li><li><code>zvals</code>: Matrix for storing the drawn <code>z</code> values from <code>N(0, I)</code>.</li></ul><p>Optimisation:</p><ul><li><code>obj_values</code>: Cache array for storing the objective function values at each optimisation restart.</li><li><code>stacked_params</code>: Matrix which stores parameter values at each optimisation restart. The columns take the form <code>[α; β; γ]</code>.</li></ul><p><em>PDE geometry</em>:</p><ul><li><code>N</code>: The length of <code>meshPoints</code>.</li><li><code>Δx</code>: The spacing between each point in <code>meshPoints</code>.</li><li><code>V</code>: The volume of each cell in the spatial mesh.</li></ul><p><em>PDE computation</em>:</p><ul><li><code>Du</code>: Cache array for computing <code>D(u)</code>.</li><li><code>D′u</code>: Cache array for computing <code>D′(u)</code>.</li><li><code>Ru</code>: Cache array for computing <code>R(u)</code>.</li><li><code>R′u</code>: Cache array for computing <code>R′(u)</code>.</li><li><code>TuP</code>: Cache array for storing the values of the delay function at the unscaled times (for the <code>&quot;PDE&quot;</code> loss function).</li><li><code>DuP</code>: Cache array for storing the values of the diffusion function at the estimated density values (for the <code>&quot;PDE&quot;</code> loss function).</li><li><code>D′uP</code>: Cache array for storing the values of the derivative of the diffusion function at the estimated density values (for the <code>&quot;PDE&quot;</code> loss function).</li><li><code>RuP</code>: Cache array for storing the values of the reaction function at the estimated density values (for the <code>&quot;PDE&quot;</code> loss function).</li><li><code>R′uP</code>: Cache array for storing the values of the derivative of the reaction function at the estimated density values (for the <code>&quot;PDE&quot;</code> loss function).</li><li><code>RuN</code>: For storing values of the reaction function at Gauss-Legendre quadrature nodes.</li></ul><p><em>PDE loss function</em>:</p><ul><li><code>SSEArray</code>: Cache array for storing the solutions to the PDEs.</li><li><code>Xₛ₀</code>: Logical array used for accessing the values in <code>Xₛ</code> corresponding to the initial condition.</li><li><code>IC1</code>: Cache array for storing the initial spline over the initial data.</li><li><code>initialCondition</code>: Cache array for storing the initial condition over <code>meshPoints</code>.</li><li><code>MSE</code>: Cache array for storing the individual squared errors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/bootstrapping.jl#L204-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.bootstrap_helper-Tuple{Any, Any, Any, Any, Any, Any, Any, GP_Setup, Bootstrap_Setup, PDE_Setup, Any}" href="#EquationLearning.bootstrap_helper-Tuple{Any, Any, Any, Any, Any, Any, Any, GP_Setup, Bootstrap_Setup, PDE_Setup, Any}"><code>EquationLearning.bootstrap_helper</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bootstrap_helper(x, t, α₀, β₀, γ₀, lowers, uppers, gp_setup::GP_Setup, bootstrap_setup::Bootstrap_Setup, pde_setup::PDE_Setup)</code></pre><p>Method for calling <a href="index.html#EquationLearning.bootstrap_helper-NTuple{16, Any}"><code>bootstrap_helper</code></a> using the setup structs from <a href="ref.html#EquationLearning.GP_Setup"><code>GP_Setup</code></a>, <a href="ref.html#EquationLearning.Bootstrap_Setup"><code>Bootstrap_Setup</code></a>, and <a href="ref.html#EquationLearning.PDE_Setup"><code>PDE_Setup</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/bootstrapping.jl#L312-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.preallocate_bootstrap-NTuple{6, Any}" href="#EquationLearning.preallocate_bootstrap-NTuple{6, Any}"><code>EquationLearning.preallocate_bootstrap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">preallocate_bootstrap(nₓnₜ, α₀, β₀, γ₀, B)</code></pre><p>Creates cache arrays and computes certain parameters  that are used for the bootstrapping component. See <a href="index.html#EquationLearning.bootstrap_helper-NTuple{16, Any}"><code>bootstrap_helper</code></a> for details and <a href="ref.html#EquationLearning.bootstrap_gp"><code>bootstrap_gp</code></a> for its use. </p><p><strong>Arguments</strong></p><ul><li><code>nₓnₜ</code>: The number of test data points.</li><li><code>α₀</code>: Initial values for the delay coefficients. (Not actually used anywhere other than for computing the number of delay parameters and checking arguments.)</li><li><code>β₀</code>: Initial values for the diffusion coefficients. (Not actually used anywhere other than for computing the number of diffusion parameters and checking arguments.)</li><li><code>γ₀</code>: Initial values for the reaction coefficients. (Not actually used anywhere other than for computing the number of reaction parameters and checking arguments.)</li><li><code>B</code>: Number of bootstrap iterations being performed.</li></ul><p><strong>Outputs</strong></p><ul><li><code>f</code>: Cache array for <code>f(x, t)</code>.</li><li><code>fₜ</code>: Cache array for <code>fₜ(x, t)</code>.</li><li><code>fₓ</code>: Cache array for <code>fₓ(x, t)</code>.</li><li><code>fₓₓ</code>: Cache array for <code>fₓₓ(x, t)</code>.</li><li><code>ffₜfₓfₓₓ</code>: Cache array for the stacked vector <code>[f; fₜ; fₓ; fₓₓ]</code>.</li><li><code>f_idx</code>: Indices for extracting <code>f(x, t)</code> from <code>ffₜfₓfₓₓ</code> from the random samples. </li><li><code>fₜ_idx</code>: Indices for extracting <code>fₜ(x, t)</code> from <code>ffₜfₓfₓₓ</code> from the random samples.</li><li><code>fₓ_idx</code>: Indices for extracting <code>fₓ(x, t)</code> from <code>ffₜfₓfₓₓ</code> from the random samples.</li><li><code>fₓₓ_idx</code>: Indices for extracting <code>fₓₓ(x, t)</code> from <code>ffₜfₓfₓₓ</code> from the random samples.</li><li><code>tt</code>: Number of delay parameters.</li><li><code>d</code>: Number of diffusion parameters.</li><li><code>r</code>: Number of reaction parameters.</li><li><code>delayBases</code>: Matrix for storing the computed delay coefficients. Each column represents a set of parameters.</li><li><code>diffusionBases</code>: Matrix for storing the computed diffusion coefficients. Each column represents a set of parameters.</li><li><code>reactionBases</code>: Matrix for storing the computed reaction coefficients. Each column represents a set of parameters.</li><li><code>ℓz</code>: Cache array for storing the result of the matrix-vector product <code>Lz</code>, where <code>L</code> is the Cholesky factor and <code>z</code> is a random sample from <code>N(0, I)</code>.</li><li><code>zvals</code>: Matrix for storing the drawn <code>z</code> values from <code>N(0, I)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/bootstrapping.jl#L57-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.preallocate_eqlearn-NTuple{12, Any}" href="#EquationLearning.preallocate_eqlearn-NTuple{12, Any}"><code>EquationLearning.preallocate_eqlearn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">preallocate_eqlearn(num_restarts, σ₁, σ₂, σ₃, meshPoints, δt, finalTime, Xₛ, tt, d, r, nₓnₜ, gp)</code></pre><p>Creates cache arrays and computes certain parameters that are used for the bootstrapping component.  See <a href="index.html#EquationLearning.bootstrap_helper-NTuple{16, Any}"><code>bootstrap_helper</code></a> for details and <a href="ref.html#EquationLearning.bootstrap_gp"><code>bootstrap_gp</code></a> for its use. </p><p><strong>Arguments</strong></p><ul><li><code>num_restarts</code>: Number of times to restart the optimisation problem when solving the nonlinear least squares problems. See <a href="index.html#EquationLearning.learn_equations!-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Vararg{Any}}"><code>learn_equations!</code></a>.</li><li><code>meshPoints</code>: The spatial mesh used for solving the PDEs.</li><li><code>δt</code>: A number or a vector specifying the spacing between returned times for the solutions to the PDEs or specific times, respectively.</li><li><code>finalTime</code>: The final time to give the solution to the PDEs at.</li><li><code>Xₛ</code>: The test matrix for the bootstrapping grid data.</li><li><code>tt</code>: Number of delay parameters.</li><li><code>d</code>: Number of diffusion parameters.</li><li><code>r</code>: Number of reaction parameters.</li><li><code>nₓnₜ</code>: The number of test data points.</li><li><code>gp</code>: The fitted Gaussian process. See <a href="ref.html#EquationLearning.fit_GP"><code>fit_GP</code></a>.</li><li><code>lowers</code>: Lower bounds for the delay, diffusion, and reaction parameters (in that order) for constructing the Latin hypercube design (only for the grid, these do not constrain the parameter values).</li><li><code>uppers</code>: Upper bounds for the delay, diffusion, and reaction parameters (in that order) for constructing the Latin hypercube design (only for the grid, these do not constrain the parameter values).</li></ul><p><strong>Outputs</strong></p><ul><li><code>obj_values</code>: Cache array for storing the objective function values at each optimisation restart.</li><li><code>stacked_params</code>: Matrix which stores parameter values at each optimisation restart. The columns take the form <code>[α; β; γ]</code>.</li><li><code>N</code>: The length of <code>meshPoints</code>.</li><li><code>Δx</code>: The spacing between each point in <code>meshPoints</code>.</li><li><code>V</code>: The volume of each cell in the spatial mesh.</li><li><code>Du</code>: Cache array for computing <code>D(u)</code>.</li><li><code>D′u</code>: Cache array for computing <code>D′(u)</code>.</li><li><code>Ru</code>: Cache array for computing <code>R(u)</code>.</li><li><code>R′u</code>: Cache array for computing <code>R′(u)</code>.</li><li><code>TuP</code>: Cache array for storing the values of the delay function at the unscaled times (for the <code>&quot;PDE&quot;</code> loss function).</li><li><code>DuP</code>: Cache array for storing the values of the diffusion function at the estimated density values (for the <code>&quot;PDE&quot;</code> loss function).</li><li><code>D′uP</code>: Cache array for storing the values of the derivative of the diffusion function at the estimated density values (for the <code>&quot;PDE&quot;</code> loss function).</li><li><code>R′uP</code>: Cache array for storing the values of the derivative of the reaction function at the estimated density values (for the <code>&quot;PDE&quot;</code> loss function).</li><li><code>RuP</code>: Cache array for storing the values of the reaction function at the estimated density values (for the <code>&quot;PDE&quot;</code> loss function).</li><li><code>RuN</code>: For storing values of the reaction function at Gauss-Legendre quadrature nodes.</li><li><code>SSEArray</code>: Cache array for storing the solutions to the PDEs.</li><li><code>Xₛ₀</code>: Logical array used for accessing the values in <code>Xₛ</code> corresponding to the initial condition.</li><li><code>IC1</code>: Cache array for storing the initial spline over the initial data.</li><li><code>initialCondition</code>: Cache array for storing the initial condition over <code>meshPoints</code>.</li><li><code>MSE</code>: Cache array for storing the individual squared errors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/bootstrapping.jl#L124-L165">source</a></section></article><h2 id="comparison.jl"><a class="docs-heading-anchor" href="#comparison.jl">comparison.jl</a><a id="comparison.jl-1"></a><a class="docs-heading-anchor-permalink" href="#comparison.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.AIC-Tuple{Union{BasisBootResults, BootResults}, Any, Any, Any}" href="#EquationLearning.AIC-Tuple{Union{BasisBootResults, BootResults}, Any, Any, Any}"><code>EquationLearning.AIC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AIC(bgp::Union{BootResults, BasisBootResults}; correct = true)</code></pre><p>Computes all the AIC values for the results in <code>bgp</code>. A small-sample size correction is used  if <code>correct = true</code>. The formulas used are given in Eq. 6 (uncorrected) or Eq. 17 (corrected) of Banks and Joyner (2017) [https://doi.org/10.1016/j.aml.2017.05.005].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/comparison.jl#L9-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.classify_Δᵢ-Tuple{Float64}" href="#EquationLearning.classify_Δᵢ-Tuple{Float64}"><code>EquationLearning.classify_Δᵢ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">classify_Δᵢ(Δᵢ::Float64)</code></pre><p>Classifies <code>Δᵢ</code>, the AICᵢ difference AICᵢ - AICₘᵢₙ, based on the guidelines by Burnham and Anderson, 2004:</p><ul><li><code>Δᵢ ≤ 3.0</code>: Returns <code>1</code>, meaning there is substantial evidence that this model is the optimal model.</li><li><code>3.0 &lt; Δᵢ ≤ 8.0</code>: Returns <code>2</code>, meaning there is considerably less evidence in favour of this model being optimal.</li><li><code>Δᵢ &gt; 8.0</code>: Returns <code>3</code>, meaning there is essentially no evidence that this model is optimal.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/comparison.jl#L60-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.compare_AICs-Tuple{Any, Any, Any, Vararg{Union{BasisBootResults, BootResults}}}" href="#EquationLearning.compare_AICs-Tuple{Any, Any, Any, Vararg{Union{BasisBootResults, BootResults}}}"><code>EquationLearning.compare_AICs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compare_AICs(x, t, u, models::Union{BootResults, BasisBootResults}...; correct = true)</code></pre><p>Compare several bootstrapped models using AIC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/comparison.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.compare_AICs-Tuple{Vararg{Float64}}" href="#EquationLearning.compare_AICs-Tuple{Vararg{Float64}}"><code>EquationLearning.compare_AICs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compare_AICs(AICs::Float64...)</code></pre><p>Compares the AIC values in <code>AICs...</code>. See also <a href="index.html#EquationLearning.classify_Δᵢ-Tuple{Float64}"><code>classify_Δᵢ</code></a> and <a href="ref.html#EquationLearning.AIC"><code>AIC</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/comparison.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.compare_AICs-Tuple{Vararg{Vector{Float64}}}" href="#EquationLearning.compare_AICs-Tuple{Vararg{Vector{Float64}}}"><code>EquationLearning.compare_AICs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compare_AICs(AICs::Vector{Float64}...)</code></pre><p>Compares many AICs by comparing entry-wise. The results are averaged. Assumes that each AIC is of equal length,  otherwise computes only up to the minimum length. The returned value is such that the <code>(i, j)</code> entry  gives the proportion of times that model <code>i</code> has been given interpretation <code>j</code> from <a href="index.html#EquationLearning.classify_Δᵢ-Tuple{Float64}"><code>classify_Δᵢ</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/comparison.jl#L89-L95">source</a></section></article><h2 id="gps.jl"><a class="docs-heading-anchor" href="#gps.jl">gps.jl</a><a id="gps.jl-1"></a><a class="docs-heading-anchor-permalink" href="#gps.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.compute_joint_GP-Tuple{GaussianProcesses.GPBase, Any}" href="#EquationLearning.compute_joint_GP-Tuple{GaussianProcesses.GPBase, Any}"><code>EquationLearning.compute_joint_GP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_joint_GP(gp::GPBase, X̃; nugget = 1e-10)</code></pre><p>Computes the mean vector <code>μ</code> and Cholesky factor <code>L</code> such that <code>LLᵀ = Σ</code>, where </p><p><span>$\left[\begin{array}{c} \mathbf{f} \\ \frac{\partial\mathbf f}{\partial t} \\ \frac{\partial\mathbf f}{\partial x} \\\frac{\partial^2\mathbf f}{\partial x^2}\end{array}\right] \sim \mathcal N\left(\mathbf{\mu}, \mathbf{\Sigma}\right).$</span></p><p><strong>Arguments</strong></p><ul><li><code>gp::GPBase</code>: The fitted Gaussian process. </li><li><code>X̃</code>: Test data for the Gaussian process. </li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>nugget = 1e-10</code>: The term to add to the diagonals of the covariance matrix in case the matrix is not positive definite.</li></ul><p><strong>Outputs</strong></p><ul><li><code>μ</code>: The mean vector. </li><li><code>L</code>: The Cholesky factor of the covariance matrix.</li></ul><p><strong>Extended help</strong></p><p>The covariance matrices are built without any attention to symmetry. The loops could be optimised by  e.g. considering only the upper triangular components. </p><p>The covariance matrices are built using separate functions for the derivatives of the kernel function (currently  only implemented for the squared exponential kernel). These functions are:</p><ul><li><a href="index.html#EquationLearning.dkxⱼ-NTuple{6, Any}"><code>dkxⱼ(x₁, t₁, x₂, t₂, ℓ₁, ℓ₂)</code></a>.</li><li><a href="index.html#EquationLearning.d²kxⱼ-NTuple{6, Any}"><code>d²kxⱼ(x₁, t₁, x₂, t₂, ℓ₁, ℓ₂)</code></a>.</li><li><a href="index.html#EquationLearning.dktⱼ-NTuple{6, Any}"><code>dktⱼ(x₁, t₁, x₂, t₂, ℓ₁, ℓ₂)</code></a>.</li><li><a href="index.html#EquationLearning.dktᵢ-NTuple{6, Any}"><code>dktᵢ(x₁, t₁, x₂, t₂, ℓ₁, ℓ₂)</code></a>.</li><li><a href="index.html#EquationLearning.d²ktᵢtⱼ-NTuple{6, Any}"><code>d²ktᵢtⱼ(x₁, t₁, x₂, t₂, ℓ₁, ℓ₂)</code></a>.</li><li><a href="index.html#EquationLearning.d²ktᵢxⱼ-NTuple{6, Any}"><code>d²ktᵢxⱼ(x₁, t₁, x₂, t₂, ℓ₁, ℓ₂)</code></a>.</li><li><a href="index.html#EquationLearning.d³tᵢxⱼ²-NTuple{6, Any}"><code>d³tᵢxⱼ²(x₁, t₁, x₂, t₂, ℓ₁, ℓ₂)</code></a>.</li><li><a href="index.html#EquationLearning.dkxᵢ-NTuple{6, Any}"><code>dkxᵢ(x₁, t₁, x₂, t₂, ℓ₁, ℓ₂)</code></a>.</li><li><a href="index.html#EquationLearning.d²kxᵢtⱼ-NTuple{6, Any}"><code>d²kxᵢtⱼ(x₁, t₁, x₂, t₂, ℓ₁, ℓ₂)</code></a>.</li><li><a href="index.html#EquationLearning.d²kxᵢxⱼ-NTuple{6, Any}"><code>d²kxᵢxⱼ(x₁, t₁, x₂, t₂, ℓ₁, ℓ₂)</code></a>.</li><li><a href="index.html#EquationLearning.d³kxᵢxⱼ²-NTuple{6, Any}"><code>d³kxᵢxⱼ²(x₁, t₁, x₂, t₂, ℓ₁, ℓ₂)</code></a>.</li><li><a href="index.html#EquationLearning.d²kxᵢ-NTuple{6, Any}"><code>d²kxᵢ(x₁, t₁, x₂, t₂, ℓ₁, ℓ₂)</code></a>.</li><li><a href="index.html#EquationLearning.d³kxᵢ²tⱼ-NTuple{6, Any}"><code>d³kxᵢ²tⱼ(x₁, t₁, x₂, t₂, ℓ₁, ℓ₂)</code></a>.</li><li><a href="index.html#EquationLearning.d³kxᵢ²xⱼ-NTuple{6, Any}"><code>d³kxᵢ²xⱼ(x₁, t₁, x₂, t₂, ℓ₁, ℓ₂)</code></a>.</li><li><a href="index.html#EquationLearning.d⁴kxᵢ²xⱼ²-NTuple{6, Any}"><code>d⁴kxᵢ²xⱼ²(x₁, t₁, x₂, t₂, ℓ₁, ℓ₂)</code></a>.</li></ul><p>In these functions, the derivatives are evaluated at <code>([x₁; t₁], [x₂; t₂])</code> with length scales  <code>(ℓ₁, ℓ₂)</code> for space and time, respectively. The functions are missing a multiplication by the  kernel value <code>cov(gp.kernel, [x₁; t₁], [x₂; t₂])</code> to allow for it to be done in place more easily.  Note also that in some of these functions, powers are written as products, e.g. <code>x³ = x*x*x</code>, to allow  for the <code>@muladd</code> macro to work (see https://github.com/SciML/MuladdMacro.jl). Since the functions are  quite small, we use <code>@inline</code> on each function to encourage the compiler to inline the function  in the LLVM.</p><p>You may get a <code>StackOverflowError</code> from this function. This may be related to https://github.com/JuliaLang/julia/issues/43242, in which case you can set the number of BLAS threads to 1:</p><pre><code class="language-julia-repl hljs">julia&gt; ccall((:openblas_get_num_threads64_, Base.libblas_name), Cint, ()) # In case you need to remember how many threads you used prior
julia&gt; LinearAlgebra.BLAS.set_num_threads(1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/gps.jl#L159-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.dktᵢ-NTuple{6, Any}" href="#EquationLearning.dktᵢ-NTuple{6, Any}"><code>EquationLearning.dktᵢ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="ref.html#EquationLearning.compute_joint_GP"><code>compute_joint_GP</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/gps.jl#L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.dktⱼ-NTuple{6, Any}" href="#EquationLearning.dktⱼ-NTuple{6, Any}"><code>EquationLearning.dktⱼ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="ref.html#EquationLearning.compute_joint_GP"><code>compute_joint_GP</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/gps.jl#L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.dkxᵢ-NTuple{6, Any}" href="#EquationLearning.dkxᵢ-NTuple{6, Any}"><code>EquationLearning.dkxᵢ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="ref.html#EquationLearning.compute_joint_GP"><code>compute_joint_GP</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/gps.jl#L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.dkxⱼ-NTuple{6, Any}" href="#EquationLearning.dkxⱼ-NTuple{6, Any}"><code>EquationLearning.dkxⱼ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="ref.html#EquationLearning.compute_joint_GP"><code>compute_joint_GP</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/gps.jl#L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.draw_gp!-Tuple{Any, Any, LinearAlgebra.LowerTriangular, Any, Any}" href="#EquationLearning.draw_gp!-Tuple{Any, Any, LinearAlgebra.LowerTriangular, Any, Any}"><code>EquationLearning.draw_gp!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw_gp!(F, μ, L::LowerTriangular, z, ℓz)</code></pre><p>Draws a random sample from a Gaussian process with mean <code>μ</code> and  covariance matrix <code>Σ = LLᵀ</code> corresponding to <code>z ∼ N(0, I)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>F</code>: Cache array used for storing the random sample.</li><li><code>μ</code>: The mean vector.</li><li><code>L::LowerTriangular</code>: The Cholesky factor of the covariance matrix.</li><li><code>z</code>: The random sample from <code>z ∼ N(0, I)</code>.</li><li><code>ℓz</code>: Cache array for storing the result of the matrix-vector product <code>Lz</code>.</li></ul><p><strong>Outputs</strong></p><p>The random sample is updated in-place into <code>F</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/gps.jl#L335-L350">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.d²ktᵢtⱼ-NTuple{6, Any}" href="#EquationLearning.d²ktᵢtⱼ-NTuple{6, Any}"><code>EquationLearning.d²ktᵢtⱼ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="ref.html#EquationLearning.compute_joint_GP"><code>compute_joint_GP</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/gps.jl#L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.d²ktᵢxⱼ-NTuple{6, Any}" href="#EquationLearning.d²ktᵢxⱼ-NTuple{6, Any}"><code>EquationLearning.d²ktᵢxⱼ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="ref.html#EquationLearning.compute_joint_GP"><code>compute_joint_GP</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/gps.jl#L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.d²kxᵢ-NTuple{6, Any}" href="#EquationLearning.d²kxᵢ-NTuple{6, Any}"><code>EquationLearning.d²kxᵢ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="ref.html#EquationLearning.compute_joint_GP"><code>compute_joint_GP</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/gps.jl#L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.d²kxᵢtⱼ-NTuple{6, Any}" href="#EquationLearning.d²kxᵢtⱼ-NTuple{6, Any}"><code>EquationLearning.d²kxᵢtⱼ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="ref.html#EquationLearning.compute_joint_GP"><code>compute_joint_GP</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/gps.jl#L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.d²kxᵢxⱼ-NTuple{6, Any}" href="#EquationLearning.d²kxᵢxⱼ-NTuple{6, Any}"><code>EquationLearning.d²kxᵢxⱼ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="ref.html#EquationLearning.compute_joint_GP"><code>compute_joint_GP</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/gps.jl#L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.d²kxⱼ-NTuple{6, Any}" href="#EquationLearning.d²kxⱼ-NTuple{6, Any}"><code>EquationLearning.d²kxⱼ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="ref.html#EquationLearning.compute_joint_GP"><code>compute_joint_GP</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/gps.jl#L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.d³kxᵢxⱼ²-NTuple{6, Any}" href="#EquationLearning.d³kxᵢxⱼ²-NTuple{6, Any}"><code>EquationLearning.d³kxᵢxⱼ²</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="ref.html#EquationLearning.compute_joint_GP"><code>compute_joint_GP</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/gps.jl#L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.d³kxᵢ²tⱼ-NTuple{6, Any}" href="#EquationLearning.d³kxᵢ²tⱼ-NTuple{6, Any}"><code>EquationLearning.d³kxᵢ²tⱼ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="ref.html#EquationLearning.compute_joint_GP"><code>compute_joint_GP</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/gps.jl#L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.d³kxᵢ²xⱼ-NTuple{6, Any}" href="#EquationLearning.d³kxᵢ²xⱼ-NTuple{6, Any}"><code>EquationLearning.d³kxᵢ²xⱼ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="ref.html#EquationLearning.compute_joint_GP"><code>compute_joint_GP</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/gps.jl#L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.d³tᵢxⱼ²-NTuple{6, Any}" href="#EquationLearning.d³tᵢxⱼ²-NTuple{6, Any}"><code>EquationLearning.d³tᵢxⱼ²</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="ref.html#EquationLearning.compute_joint_GP"><code>compute_joint_GP</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/gps.jl#L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.d⁴kxᵢ²xⱼ²-NTuple{6, Any}" href="#EquationLearning.d⁴kxᵢ²xⱼ²-NTuple{6, Any}"><code>EquationLearning.d⁴kxᵢ²xⱼ²</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="ref.html#EquationLearning.compute_joint_GP"><code>compute_joint_GP</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/gps.jl#L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.fit_GP-Tuple{Any, Any, Any, GP_Setup}" href="#EquationLearning.fit_GP-Tuple{Any, Any, Any, GP_Setup}"><code>EquationLearning.fit_GP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit_GP(x, t, u, setup::GP_Setup)</code></pre><p>Method for calling <a href="ref.html#EquationLearning.fit_GP"><code>fit_GP</code></a> with a setup defined by <a href="ref.html#EquationLearning.GP_Setup"><code>GP_Setup</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/gps.jl#L104-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.fit_GP-Tuple{Any, Any, Any}" href="#EquationLearning.fit_GP-Tuple{Any, Any, Any}"><code>EquationLearning.fit_GP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit_GP(x, t, u; &lt;keyword arguments&gt;)</code></pre><p>Fits a Gaussian process with data <code>(x, t)</code> using the targets in <code>u</code>. </p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The spatial data. </li><li><code>t</code>: The temporal data.</li><li><code>u</code>: The targets corresponding to <code>(x, t)</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ℓₓ = log.([1e-4, 1.0])</code>: A 2-vector giving the lower and upper bounds for the initial estimates of <code>ℓₓ</code> (defined on a log scale).</li><li><code>ℓₜ = log.([1e-4, 1.0])</code>: A 2-vector giving the lower and upper bounds for the initial estimates of <code>ℓₜ</code> (defined on a log scale).</li><li><code>σ = log.([1e-1, 2std(u)])</code>: A 2-vector giving the lower and upper bounds for the initial estimates of <code>σ</code> (defined on a log scale).</li><li><code>σₙ = log.([1e-5, 2std(u)])</code>: A 2-vector giving the lower and upper bounds for the initial estimates of <code>σₙ</code> (defined on a log scale).</li><li><code>num_restarts = 50</code>: Number of times to restart the optimiser. See <a href="index.html#EquationLearning.opt_restart!-NTuple{5, Any}"><code>opt_restart!</code></a>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>gp</code>: The fitted Gaussian process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/gps.jl#L58-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.opt_restart!-NTuple{5, Any}" href="#EquationLearning.opt_restart!-NTuple{5, Any}"><code>EquationLearning.opt_restart!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">opt_restart!(gp, ℓₓ, ℓₜ, σ, σₙ; num_restarts = 50)</code></pre><p>Given a Gaussian process <code>gp</code>, fit many new Gaussian processes with new initial estimates for the hyperparameters. The  initial estimates are chosen based on provided ranges for the hyperparameters and Latin hypercube sampling. See also <a href="ref.html#EquationLearning.fit_GP"><code>fit_GP</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>gp</code>: A Gaussian process object, fitted uses the <code>GaussianProcesses.jl</code> package. </li><li><code>ℓₓ</code>: A 2-vector giving the lower and upper bounds for the initial estimates of <code>ℓₓ</code> (defined on a log scale).</li><li><code>ℓₜ</code>: A 2-vector giving the lower and upper bounds for the initial estimates of <code>ℓₜ</code> (defined on a log scale).</li><li><code>σ</code>: A 2-vector giving the lower and upper bounds for the initial estimates of <code>σ</code> (defined on a log scale).</li><li><code>σₙ</code>: A 2-vector giving the lower and upper bounds for the initial estimates of <code>σₙ</code> (defined on a log scale).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>num_restarts = 50</code>: The number of restarts to perform.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/gps.jl#L10-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.precompute_gp_mean-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Bootstrap_Setup}" href="#EquationLearning.precompute_gp_mean-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Bootstrap_Setup}"><code>EquationLearning.precompute_gp_mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">precompute_gp_mean(x, t, u, ℓₓ, ℓₜ, σ, σₙ, nugget, num_restarts, bootstrap_setup::Bootstrap_Setup)</code></pre><p>Computes the Gaussian process and corresponding mean vector and Cholesky factor for a  joint Gaussian process defined by the data <code>(x, t, u)</code>. See also  <a href="ref.html#EquationLearning.compute_joint_GP"><code>compute_joint_GP</code></a> and <a href="ref.html#EquationLearning.bootstrap_gp"><code>bootstrap_gp</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The spatial data. </li><li><code>t</code>: The temporal data.</li><li><code>u</code>: The targets corresponding to <code>(x, t)</code>.</li><li><code>ℓₓ</code>: A 2-vector giving the lower and upper bounds for the initial estimates of <code>ℓₓ</code> (defined on a log scale).</li><li><code>ℓₜ</code>: A 2-vector giving the lower and upper bounds for the initial estimates of <code>ℓₜ</code> (defined on a log scale).</li><li><code>σ</code>: A 2-vector giving the lower and upper bounds for the initial estimates of <code>σ</code> (defined on a log scale).</li><li><code>σₙ</code>: A 2-vector giving the lower and upper bounds for the initial estimates of <code>σₙ</code> (defined on a log scale).</li><li><code>nugget</code>: The term to add to the diagonals of the covariance matrix in case the matrix is not positive definite.</li><li><code>num_restarts = 50</code>: Number of times to restart the optimiser. See <a href="index.html#EquationLearning.opt_restart!-NTuple{5, Any}"><code>opt_restart!</code></a>.</li><li><code>bootstrap_setup::Bootstrap_Setup</code>: A <a href="ref.html#EquationLearning.Bootstrap_Setup"><code>Bootstrap_Setup</code></a> struct for defining the bootstrapping grid.</li></ul><p><strong>Outputs</strong></p><ul><li><code>gp_setup</code>: The fitted Gaussian process.</li><li><code>μ</code>: The mean vector for the joint Gaussian proces.</li><li><code>L</code>: The Cholesky factor for the joint Gaussian process.</li></ul><p>`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/gps.jl#L356-L380">source</a></section></article><h2 id="optimisation.jl"><a class="docs-heading-anchor" href="#optimisation.jl">optimisation.jl</a><a id="optimisation.jl-1"></a><a class="docs-heading-anchor-permalink" href="#optimisation.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.check_constraints-Tuple{Any, Any}" href="#EquationLearning.check_constraints-Tuple{Any, Any}"><code>EquationLearning.check_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_constraints(Tval, Dval)</code></pre><p>Checks if <code>Tval &lt; 0.0</code> or if <code>Dval &lt; 0.0</code>. If either of these conditions are true, returns <code>true</code>; otherwise <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/optimisation.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.check_constraints-Tuple{Any, Function, Function, Function, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}" href="#EquationLearning.check_constraints-Tuple{Any, Function, Function, Function, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}"><code>EquationLearning.check_constraints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_constraints(αβγ, T::Function, D::Function, R::Function, α, β, γ, T_params, D_params, R_params, 
    finalTime, maxf, glnodes, glweights, RuN, uvals, tvals)</code></pre><p>Checks if the current parameter values violate the constraints <code>D &gt; 0</code>, <code>T &gt; 0</code>, <code>∫R &gt; 0</code>.</p><p><strong>Arguments</strong></p><ul><li><code>αβγ</code>: The parameter values for the delay, diffusion, and reaction terms, given in the form <code>[α, β, γ]</code>.</li><li><code>T::Function</code>: The delay function, given in the form <code>T(t, α...)</code>.</li><li><code>D::Function</code>: The diffusion function, given in the form <code>D(u, β...)</code>.</li><li><code>R::Function</code>: The reaction function, given in the form <code>R(u, γ...)</code>.</li><li><code>α</code>: Initial estimates for the delay parameters.</li><li><code>β</code>: Initial estimates for the diffusion parameters. </li><li><code>γ</code>: Initial estimates for the reaction parameters.</li><li><code>T_params</code>: Additional known parameters for the delay function.</li><li><code>D_params</code>: Additional known parameters for the diffusion function.</li><li><code>R_params</code>: Additional known parameters for the reaction function. </li><li><code>finalTime</code>: The final time to give the solution to the PDE at.</li><li><code>maxf</code>: The maximum value of <code>f</code>.</li><li><code>glnodes</code>: Gauss-Legendre quadrature nodes.</li><li><code>glweights</code>: Gauss-Legendre quadrature weights.</li><li><code>RuN</code>: For storing values of the reaction function at Gauss-Legendre quadrature nodes.</li><li><code>uvals</code>: Values for <code>u</code> used for testing constraints. </li><li><code>tvals</code>: Values for <code>t</code> used for testing constraints.</li></ul><p><strong>Output</strong></p><ul><li><code>true</code> is any of the constraints are violated, and <code>false</code> otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/optimisation.jl#L8-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.learn_equations!-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Vararg{Any}}" href="#EquationLearning.learn_equations!-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Vararg{Any}}"><code>EquationLearning.learn_equations!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">learn_equations!(&lt;arguments&gt;)</code></pre><p>Estimate values for the delay, diffusion, and reaction parameters. See <a href="ref.html#EquationLearning.bootstrap_gp"><code>bootstrap_gp</code></a> and <a href="index.html#EquationLearning.loss_function-Tuple{Any}"><code>loss_function</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The spatial data.</li><li><code>t</code>: The temporal data.</li><li><code>u</code>: The density data.</li><li><code>f</code>: Computed values of <code>f(x, t)</code>.</li><li><code>fₜ</code>: Computed values of <code>fₜ(x, t)</code>.</li><li><code>fₓ</code>: Computed values of <code>fₓ(x, t)</code>.</li><li><code>fₓₓ</code>: Computed values of <code>fₓₓ(x, t)</code>.</li><li><code>T::Function</code>: The delay function, given in the form <code>T(t, α., )</code>.</li><li><code>D::Function</code>: The diffusion function, given in the form <code>D(u, β...)</code>.</li><li><code>D′::Function</code>: The derivative of the diffusion function, given in the form <code>D′(u, β...)</code>.</li><li><code>R::Function</code>: The reaction function, given in the form <code>R(u, γ...)</code>.</li><li><code>R′::Function</code>: The derivative of the reaction function, given in the form <code>R′(u, γ, R_params)</code>.</li><li><code>T_params</code>: Additional known parameters for the delay function.</li><li><code>D_params</code>: Additional known parameters for the diffusion function.</li><li><code>R_params</code>: Additional known parameters for the reaction function. </li><li><code>α</code>: Initial estimates for the delay parameters.</li><li><code>β</code>: Initial estimates for the diffusion parameters. </li><li><code>γ</code>: Initial estimates for the reaction parameters.</li><li><code>stacked_params</code>: Matrix which stores parameter values at each optimisation restart. The columns take the form <code>[α₀; β₀; γ₀]</code>.</li><li><code>lowers</code>: Lower bounds to use for constructing the Latin hypersquare design, and for the constrained problem if <code>bootstrap_setup.constrained = true</code>.</li><li><code>uppers</code>: Upper bounds to use for constructing the Latin hypersquare design, and for the constrained problem if <code>bootstrap_setup.constrained = true</code>.</li><li><code>constrained</code>: <code>true</code> if the optimisation problems should be constrained, and <code>false</code> otherwise.</li><li><code>obj_values</code>: Cache array for storing the objective function values at each optimisation restart.</li><li><code>obj_scale_GLS</code>: The amount by which the GLS loss function should be scaled.</li><li><code>obj_scale_PDE</code>: The amount by which the PDE loss function should be scaled.</li><li><code>N</code>: The number points.</li><li><code>V</code>: The volume of each cell in the spatial mesh.</li><li><code>Δx</code>: The spacing between each point in the spatial mesh.</li><li><code>LHS</code>: Vector defining the left-hand boundary conditions for the PDE. See also the definitions of <code>(a₀, b₀, c₀)</code> in <a href="index.html#EquationLearning.sysdegeneral!-NTuple{4, Any}"><code>sysdegeneral!</code></a>.</li><li><code>RHS</code>: Vector defining the right-hand boundary conditions for the PDE. See also the definitions of <code>(a₁, b₁, c₁)</code> in <a href="index.html#EquationLearning.sysdegeneral!-NTuple{4, Any}"><code>sysdegeneral!</code></a>.</li><li><code>initialCondition</code>: The initial condition to use for the PDE.</li><li><code>finalTime</code>: The final time to give the solution to the PDE at.</li><li><code>alg</code>: The algorithm to use for solving the discretised PDE.</li><li><code>δt</code>: A vector specifying the times to return the solution to the discretised PDE at.</li><li><code>SSEArray</code>: Cache array for storing the solutions to the PDE. </li><li><code>Du</code>: Cache array for storing the values of the diffusion function at the mesh points. Should be defined as a <code>PreallocationTools.DiffCache</code> type; see <a href="index.html#EquationLearning.bootstrap_helper-NTuple{16, Any}"><code>bootstrap_helper</code></a>.</li><li><code>Ru</code>: Cache array for storing the values of the reaction function at the mesh points.  Should be defined as a <code>PreallocationTools.DiffCache</code> type; see <a href="index.html#EquationLearning.bootstrap_helper-NTuple{16, Any}"><code>bootstrap_helper</code></a>.</li><li><code>D′u</code>: Cache array used for storing the values of the derivative of the diffusion function <code>D</code> at <code>D′(u)</code>.</li><li><code>R′u</code>: Cache array used for storing the values of the derivative of the reaction function <code>R</code> at <code>R′(u)</code>.</li><li><code>TuP</code>: Cache array for storing the values of the delay function at the unscaled times (for the <code>&quot;PDE&quot;</code> loss function).  Should be defined as a <code>PreallocationTools.DiffCache</code> type; see <a href="index.html#EquationLearning.bootstrap_helper-NTuple{16, Any}"><code>bootstrap_helper</code></a>.</li><li><code>DuP</code>: Cache array for storing the values of the diffusion function at the estimated density values (for the <code>&quot;PDE&quot;</code> loss function).  Should be defined as a <code>PreallocationTools.DiffCache</code> type; see <a href="index.html#EquationLearning.bootstrap_helper-NTuple{16, Any}"><code>bootstrap_helper</code></a>.</li><li><code>RuP</code>: Cache array for storing the values of the reaction function at the estimated density values (for the <code>&quot;PDE&quot;</code> loss function).  Should be defined as a <code>PreallocationTools.DiffCache</code> type; see <a href="index.html#EquationLearning.bootstrap_helper-NTuple{16, Any}"><code>bootstrap_helper</code></a>.</li><li><code>D′uP</code>: Cache array for storing the values of the derivative of the diffusion function at the estimated density values (for the <code>&quot;PDE&quot;</code> loss function).  Should be defined as a <code>PreallocationTools.DiffCache</code> type; see <a href="index.html#EquationLearning.bootstrap_helper-NTuple{16, Any}"><code>bootstrap_helper</code></a>.</li><li><code>RuN</code>: For storing values of the reaction function at Gauss-Legendre quadrature nodes.  Should be defined as a <code>PreallocationTools.DiffCache</code> type; see <a href="index.html#EquationLearning.bootstrap_helper-NTuple{16, Any}"><code>bootstrap_helper</code></a>.</li><li><code>inIdx</code>: Indices in <code>f</code> (and <code>fₜ</code>) that should be used in the optimisation process. See aso <a href="index.html#EquationLearning.data_thresholder-Tuple{Any, Any, Any}"><code>data_thresholder</code></a>.</li><li><code>unscaled_t̃</code>: Unscaled <code>t</code> values for the bootstrapping grid. </li><li><code>tt</code>: Number of delay parameters.</li><li><code>d</code>: Number of diffusion parameters.</li><li><code>r</code>: Number of reaction reaction parameters.</li><li><code>errs</code>: Cache array for storing the individual error values. Should be defined as a <code>PreallocationTools.DiffCache</code> type.</li><li><code>MSE</code>: Cache array for storing the individual squared errors. Should be defined as a <code>PreallocationTools.DiffCache</code> type.</li><li><code>optim_setup</code>: An <code>Optim.Options</code> struct used for defining options in <code>Optim.optimize</code>.</li><li><code>iterate_idx</code>: Indices to use on the data for finding indices corresponding to specific time values. See the definition in <a href="ref.html#EquationLearning.bootstrap_gp"><code>bootstrap_gp</code></a>.</li><li><code>closest_idx</code>: Points in the spatial mesh for the ODEs that are closest to the positions in the spatial data <code>x</code>. See the definition in <a href="ref.html#EquationLearning.bootstrap_gp"><code>bootstrap_gp</code></a>.</li><li><code>nodes</code>: The Gauss-Legendre quadrature nodes.</li><li><code>weights</code>: The Gauss-Legendre quadrature weights.</li><li><code>show_losses</code>: <code>true</code> if the loss function should be printed to the REPL throughout the optimisation process, and <code>false</code> otherwise.</li><li><code>σₙ</code>: The standard deviation of the observation noise, estimated from the Gaussian process.</li><li><code>init_weight</code>: Weight factor for the initial condition for the GLS errors.</li><li><code>uvals</code>: Values for <code>u</code> used for testing constraints. </li><li><code>tvals</code>: Values for <code>t</code> used for testing constraints.</li><li><code>PDEkwargs...</code>: The keyword arguments to use in <code>DifferentialEquations.solve</code>.</li></ul><p><strong>Outputs</strong></p><p>The estimates for the delay parameters, <code>α</code>, diffusion parameters, <code>β</code>, and reaction parameters,  <code>γ</code>, are updated in-place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/optimisation.jl#L222-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.loss_function-Tuple{Any}" href="#EquationLearning.loss_function-Tuple{Any}"><code>EquationLearning.loss_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loss_function(αβγ; &lt;keyword arguments&gt;)</code></pre><p>Computes the loss function at <code>αβγ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>αβγ</code>: The parameter values for the delay, diffusion, and reaction terms, given in the form <code>[α, β, γ]</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>u</code>: The density data used for fitting the Gaussian process. See <a href="ref.html#EquationLearning.fit_GP"><code>fit_GP</code></a>.</li><li><code>f</code>: Computed values of <code>f(x, t)</code>.</li><li><code>fₓ</code>: Computed values of <code>fₓ(x, t)</code>.</li><li><code>fₓₓ</code>: Computed values of <code>fₓₓ(x, t)</code>.</li><li><code>fₜ</code>: Computed values of <code>fₜ(x, t)</code>.</li><li><code>N</code>: Number of mesh points being used for solving the PDEs.</li><li><code>V</code>: The volume of each cell in the discretised PDE.</li><li><code>Δx</code>: The spacing between cells in the discretised PDE.</li><li><code>LHS</code>: Vector of the form <code>[a₀, b₀, c₀]</code> which specifies the boundary conditions. </li><li><code>RHS</code>: Vector of the form <code>[a₁, b₁, c₁]</code> which specifies the boundary conditions. </li><li><code>T</code>: The delay function, given in the form <code>T(t, α...)</code>.</li><li><code>D</code>: The diffusion function, given in the form <code>D(u, β...)</code>.</li><li><code>D′</code>: The derivative of the diffusion function, given in the form <code>D′(u, β...)</code>.</li><li><code>R</code>: The reaction function, given in the form <code>R(u, γ...)</code>.</li><li><code>R′::Function</code>: The derivative of the reaction function, given in the form <code>R′(u, γ, R_params)</code>.</li><li><code>initialCondition</code>: Vector for the initial condition for the PDE.</li><li><code>finalTime</code>: The final time to give the solution to the PDE at.</li><li><code>EQLalg</code>: The algorithm to use for solving the PDE. Cannot be a Sundials algorithm.</li><li><code>δt</code>: A number or a vector specifying the spacing between returned times for the solutions to the PDEs or specific times, respectively.</li><li><code>SSEArray</code>: Cache array for storing the solutions to the PDE. </li><li><code>Du</code>: Cache array for storing the values of the diffusion function at the mesh points.</li><li><code>Ru</code>: Cache array for storing the values of the reaction function at the mesh points. </li><li><code>D′u</code>: Cache array used for storing the values of the derivative of the diffusion function <code>D</code> at <code>D′(u)</code>.</li><li><code>R′u</code>: Cache array used for storing the values of the derivative of the reaction function <code>R</code> at <code>R′(u)</code>.</li><li><code>TuP</code>: Cache array for storing the values of the delay function at the unscaled times (for the <code>&quot;GLS&quot;</code> loss function).</li><li><code>DuP</code>: Cache array for storing the values of the diffusion function at the estimated density values (for the <code>&quot;GLS&quot;</code> loss function).</li><li><code>RuP</code>: Cache array for storing the values of the reaction function at the estimated density values (for the <code>&quot;GLS&quot;</code> loss function).</li><li><code>D′uP</code>: Cache array for storing the values of the derivative of the diffusion function at the estimated density values (for the <code>&quot;GLS&quot;</code> loss function).</li><li><code>RuN</code>: For storing values of the reaction function at Gauss-Legendre quadrature nodes.</li><li><code>inIdx</code>: The indices for the data to use. See <a href="index.html#EquationLearning.data_thresholder-Tuple{Any, Any, Any}"><code>data_thresholder</code></a>.</li><li><code>unscaled_t̃</code>: The unscaled time values on the bootstrapping grid.</li><li><code>tt</code>: The number of delay parameters.</li><li><code>d</code>: The number of diffusion parameters.</li><li><code>r</code>: The number of reaction parameters.</li><li><code>errs</code>: Cache array for storing the individual error values.</li><li><code>MSE</code>: Cache array for storing the individual squared errors.</li><li><code>obj_scale_GLS</code>: Scale to divide the <code>GLS</code> loss by.</li><li><code>obj_scale_PDE</code>: Scale to divide the <code>PDE</code> loss by.</li><li><code>glnodes</code>: Gauss-Legendre quadrature nodes.</li><li><code>glweights</code>: Gauss-Legendre quadrature weights.</li><li><code>maxf</code>: The maximum value of <code>f</code>.</li><li><code>D_params</code>: Extra parameters for the diffusion function.</li><li><code>R_params</code>: Extra parameters for the reaction function. </li><li><code>T_params</code>: Extra parameters for the delay function.</li><li><code>iterate_idx</code>: Vector used for indexing the values in <code>u</code> corresponding to different times.</li><li><code>closest_idx</code>: Vector used for indexing the points in the PDE&#39;s meshpoints that are closest to the actual spatial data used for fitting the Gaussian process.</li><li><code>show_losses</code>: Whether to print the individual loss functions to the REPL during the optimisation process.</li><li><code>σₙ</code>: The standard deviation of the observation noise of the Gaussian process.</li><li><code>init_weight</code>: Weight factor for the initial condition for the GLS errors.</li><li><code>uvals</code>: Values for <code>u</code> used for testing constraints. </li><li><code>tvals</code>: Values for <code>t</code> used for testing constraints.</li><li><code>PDEkwargs...</code>: The keyword arguments to use in <code>DifferentialEquations.solve</code>.</li></ul><p><strong>Extended help</strong></p><p>There are two types of loss functions currently considered, namely <code>&quot;GLS&quot;</code> and <code>&quot;PDE&quot;</code>. For <code>&quot;PDE&quot;</code>, the loss function is </p><p><span>$\frac{1}{n_xn_t}\sum_{i=1}^{n_x}\sum_{j=1}^{n_t}\left\{\frac{\partial u_{ij}}{\partial t} - T(t_j; \mathbf{\alpha})\left[\frac{\mathrm{d}D(u_{ij}; \mathbf{\beta})}{\mathrm du}\left(\frac{\partial u_{ij}}{x}\right)^2 + D(u_{ij}; \mathbf{\beta})\frac{\partial^2u_{ij}}{\partial x^2} + R(u_{ij}; \mathbf{\gamma})\right]\right\}.$</span></p><p>For <code>&quot;GLS&quot;</code>, the loss function is (see Lagergren et al. (2020): https://doi.org/10.1098/rspa.2019.0800)</p><p><span>$\frac{1}{NM}\sum_{i=1}^N\sum_{j=1}^M \left(\frac{\hat u_{ij} - u_{ij}}{\σ_{n}\right)^2$</span>,</p><p>If the ODE solver returns an error for the given parameter values, <code>∞</code> is added to the loss function as a penalty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/optimisation.jl#L79-L151">source</a></section></article><h2 id="pdes.jl"><a class="docs-heading-anchor" href="#pdes.jl">pdes.jl</a><a id="pdes.jl-1"></a><a class="docs-heading-anchor-permalink" href="#pdes.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.boot_pde_solve-Tuple{BootResults, Any, Any, Any}" href="#EquationLearning.boot_pde_solve-Tuple{BootResults, Any, Any, Any}"><code>EquationLearning.boot_pde_solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">boot_pde_solve(bgp::BootResults, x_pde, t_pde, u_pde; ICType = &quot;data&quot;)</code></pre><p>Solve the PDEs corresponding to the bootstrap iterates in <code>bgp</code> obtained from <a href="ref.html#EquationLearning.bootstrap_gp"><code>bootstrap_gp</code></a>. </p><p><strong>Arguments</strong></p><ul><li><code>bgp::BootResults</code>: A <a href="ref.html#EquationLearning.BootResults"><code>BootResults</code></a> struct containing the results from <a href="ref.html#EquationLearning.bootstrap_gp"><code>bootstrap_gp</code></a>.</li><li><code>x_pde</code>: The spatial data to use for obtaining the initial condition.</li><li><code>t_pde</code>: The temporal data to use for obtaining the initial condition.</li><li><code>u_pde</code>: The density data to use for obtaining the initial condition.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ICType = &quot;data&quot;</code>: The type of initial condition to use. Should be either <code>&quot;data&quot;</code> or <code>&quot;gp&quot;</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>solns_all</code>: The solutions to the PDEs over the mesh points at each time value.</li></ul><p><strong>Note</strong></p><p>The <code>_pde</code> subscript is used to indicate that these data need not be the same as the <code>(x, t, u)</code> used in <a href="ref.html#EquationLearning.bootstrap_gp"><code>bootstrap_gp</code></a>, for example. For example, we may have 3 replicates of some data which we would easily use in <a href="ref.html#EquationLearning.bootstrap_gp"><code>bootstrap_gp</code></a>, but for the PDE we would need to average these  together for obtaining the solutions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/pdes.jl#L200-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.compute_initial_conditions-Tuple{Any, Any, Any, Any, Union{BasisBootResults, BootResults}, Any, Any, Any}" href="#EquationLearning.compute_initial_conditions-Tuple{Any, Any, Any, Any, Union{BasisBootResults, BootResults}, Any, Any, Any}"><code>EquationLearning.compute_initial_conditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_initial_conditions(x_pde, t_pde, u_pde, ICType, bgp::Union{BootResults, BasisBootResults}, N, B, meshPoints)</code></pre><p>Computes initial conditions for the bootstrap iterates in <code>bgp</code>. See also <a href="ref.html#EquationLearning.bootstrap_gp"><code>bootstrap_gp</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>x_pde</code>: The spatial data used for fitting the original Gaussian process. See also <a href="ref.html#EquationLearning.fit_GP"><code>fit_GP</code></a>.</li><li><code>t_pde</code>: The temporal data used for fitting the original Gaussian process. See also <a href="ref.html#EquationLearning.fit_GP"><code>fit_GP</code></a>.</li><li><code>u_pde</code>: The density data used for fitting the original Gaussian process. See also <a href="ref.html#EquationLearning.fit_GP"><code>fit_GP</code></a>.</li><li><code>ICType</code>: The type of initial condition to use. If <code>ICType == &quot;data&quot;</code> then the initial condition is simply a spline through the data, and if <code>ICType == &quot;gp&quot;</code> then the initial condition is a sample of the underlying Gaussian process in <code>bgp.gp</code>.</li><li><code>bgp::Union{BootResults, BasisBootResults}</code>: The bootstrapping results.</li><li><code>N</code>: The number of mesh points.</li><li><code>B</code>: The number of bootstrap iterations.</li><li><code>meshPoints</code>: The spatial mesh.</li></ul><p><strong>Outputs</strong></p><ul><li><code>initialCondition_all</code>: The initial condition to use for each bootstrap iterate, with the <code>j</code>th column corresponding to the <code>j</code>th bootstrap sample.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/pdes.jl#L103-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.compute_initial_conditions-Tuple{Any, Any, Any, Union{BasisBootResults, BootResults}, Any}" href="#EquationLearning.compute_initial_conditions-Tuple{Any, Any, Any, Union{BasisBootResults, BootResults}, Any}"><code>EquationLearning.compute_initial_conditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_initial_conditions(x_pde, t_pde, u_pde, bgp::Union{BootResults, BasisBootResults})</code></pre><p>Method for calling [<code>compute_initial_conditions</code>] when providing only <code>bgp</code> and the data. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/pdes.jl#L139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.compute_valid_pde_indices-Tuple{Any, Any, Any, Any, Any, BootResults}" href="#EquationLearning.compute_valid_pde_indices-Tuple{Any, Any, Any, Any, Any, BootResults}"><code>EquationLearning.compute_valid_pde_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_valid_pde_indices(u_pde, num_t, num_u, nodes, weights, bgp::BootResults)</code></pre><p>Method for calling [<code>compute_valid_pde_indices</code>] when providing only <code>bgp</code> and the data. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/pdes.jl#L191-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.compute_valid_pde_indices-Tuple{BootResults, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}" href="#EquationLearning.compute_valid_pde_indices-Tuple{BootResults, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}"><code>EquationLearning.compute_valid_pde_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_valid_pde_indices(bgp, u_pde, num_t, num_u, B, tr, dr, rr, nodes, weights, D_params, R_params, T_params)</code></pre><p>Computes the indices corresponding to the bootstrap samples which give valid PDE solutions. The check is done by  ensuring that the delay and diffusion values are strictly nonnegative, and the area under the reaction curve is nonnegative.</p><p><strong>Arguments</strong></p><ul><li><code>bgp::BootResults</code>: The bootstrapping results of type <a href="ref.html#EquationLearning.BootResults"><code>BootResults</code></a>. See <a href="ref.html#EquationLearning.bootstrap_gp"><code>bootstrap_gp</code></a>.</li><li><code>u_pde</code>: The density data used for fitting the original Gaussian process. See also <a href="ref.html#EquationLearning.fit_GP"><code>fit_GP</code></a>.</li><li><code>num_t</code>: The number of time values to use for checking the validity of the delay function values. </li><li><code>num_u</code>: The number of density values to use for checking the validity of the diffusion function values.</li><li><code>B</code>: The number of bootstrap samples used.</li><li><code>tr</code>: The matrix of estimated delay parameters. </li><li><code>dr</code>: The matrix of estimated diffusion parameters.</li><li><code>rr</code>: The matrix of estimated reaction parameters.</li><li><code>nodes</code>: Gauss-Legendre quadrature nodes.</li><li><code>weights</code>: Gauss-Legendre quadrature weights.</li><li><code>D_params</code>: Extra parameters for the diffusion function.</li><li><code>R_params</code>: Extra parameters for the reaction function. </li><li><code>T_params</code>: Extra parameters for the delay function.</li></ul><p><strong>Outputs</strong></p><ul><li><code>idx</code>: The vector of indices corresponding to valid bootstrap samples.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/pdes.jl#L148-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.error_comp-NTuple{5, Any}" href="#EquationLearning.error_comp-NTuple{5, Any}"><code>EquationLearning.error_comp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">error_comp(bgp, solns_all, x, t, u; level = 0.05)</code></pre><p>Computes the error between solutions to a PDE compared to data <code>(x, t, u)</code> from the bootstrapping procedure. The error measure used is <code>median(100 * (absolute errors) / max(eps(Float64), u))</code>.</p><p><strong>Arguments</strong></p><ul><li><code>bgp</code>: Bootstrapping results.</li><li><code>solns_all</code>: PDE solutions.</li><li><code>x</code>: Spatial data.</li><li><code>t</code>: Temporal data.</li><li><code>u</code>: Density data.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>level = 0.05</code>: Level for the confidence interval.</li><li><code>compute_mean = false</code>: Whether to only report the mean.</li></ul><p><strong>Outputs</strong></p><ul><li><code>err_CI</code>: <code>100(1-level)%</code> confidence interval for the error.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/pdes.jl#L265-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.sysdegeneral!-NTuple{4, Any}" href="#EquationLearning.sysdegeneral!-NTuple{4, Any}"><code>EquationLearning.sysdegeneral!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sysdegeneral!(dudt, u, p, t)</code></pre><p>Function for computing the system of ODEs used in a discretised delay-reaction-diffusion PDE.</p><p><strong>Arguments</strong></p><ul><li><code>dudt</code>: A cache array used for storing the left-hand side of the system of ODEs. </li><li><code>u</code>: The current values for the variables in the systems.</li><li><code>p</code>: A tuple of parameters, given by:<ul><li><code>p[1] = N</code>: Number of mesh points being used for solving the PDE.</li><li><code>p[2] = V</code>: The volume of each cell in the discretised PDE.</li><li><code>p[3] = h</code>: The spacing between cells in the discretised PDE.</li><li><code>p[4] = a₀</code>: The coefficient on <code>u(a, t)</code> in the Robin boundary condition at <code>x = a</code> (the left end-point of the mesh). </li><li><code>p[5] = b₀</code>: The coefficient on <code>-∂u(a, t)/∂x</code> in the Robin boundary condition at <code>x = a</code> (the left end-point of the mesh).</li><li><code>p[6] = c₀</code>: The right-hand side constant in the Robin boundary condition at <code>x = a</code> (the left end-point of the mesh).</li><li><code>p[7] = a₁</code>: The coefficient on <code>u(b, t)</code> in the Robin boundary condition at <code>x = b</code> (the right end-point of the mesh). </li><li><code>p[8] = b₁</code>: The coefficient on <code>∂u(b, t)/∂t</code> in the Robin boundary condition at <code>x = b</code> (the right end-point of the mesh).</li><li><code>p[9] = c₁</code>: The right-hand side constant in the Robin boundary condition at <code>x = b</code> (the right end-point of the mesh).</li><li><code>p[10] = DD</code>: Cache array used for storing the values of the diffusion function <code>D</code> at <code>D(u)</code>.</li><li><code>p[11] = RR</code>: Cache array used for storing the values of the reaction function <code>R</code> at <code>R(u)</code>.</li><li><code>p[12] = DD′</code>: Cache array used for storing the values of the derivative of the diffusion function <code>D</code> at <code>D′(u)</code>.</li><li><code>p[13] = RR′</code>: Cache array used for storing the values of the derivative of the reaction function <code>R</code> at <code>R′(u)</code>.</li><li><code>p[14] = T</code>: The delay function, given in the form <code>T(t, α, T_params)</code>.</li><li><code>p[15] = D</code>: The diffusion function, given in the form <code>D(u, β, D_params)</code>.</li><li><code>p[16] = R</code>: The reaction function, given in the form <code>R(u, γ, R_params)</code>.</li><li><code>p[17] = D′</code>: The derivative of the diffusion function, given in the form <code>D′(u, β, D_params)</code>.</li><li><code>p[18] = R′</code>: The derivative of the reaction function, given in the form <code>R′(u, γ, R_params)</code>.</li><li><code>p[19] = tb</code>: The values of the delay parameters.</li><li><code>p[20] = db</code>: The values of the diffusion parameters.</li><li><code>p[21] = rb</code>: The values of the reaction parameters.</li><li><code>p[22] = D_params</code>: Extra parameters used in the diffusion function.</li><li><code>p[23] = R_params</code>: Extra parameters for the reaction function.</li><li><code>p[24] = T_params</code>: Extra parameters for the delay function.</li></ul></li><li><code>t</code>: The current time value.</li></ul><p><strong>Outputs</strong></p><p>The values are updated in-place into the vector <code>dudt</code> for the new value of <code>dudt</code> at time <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/pdes.jl#L10-L47">source</a></section></article><h2 id="plot_results.jl"><a class="docs-heading-anchor" href="#plot_results.jl">plot_results.jl</a><a id="plot_results.jl-1"></a><a class="docs-heading-anchor-permalink" href="#plot_results.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.curve_results-Tuple{BootResults}" href="#EquationLearning.curve_results-Tuple{BootResults}"><code>EquationLearning.curve_results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">curve_results(bgp::BootResults; &lt;keyword arguments&gt;)</code></pre><p>Plots the learned functional forms along with confidence intervals for the bootstrapping results in <code>bgp</code>.</p><p><strong>Arguments</strong></p><ul><li><code>bgp</code>: A <a href="ref.html#EquationLearning.BootResults"><code>BootResults</code></a> object which contains the results for the bootstrapping. </li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>level = 0.05</code>: The significance level for computing the credible intervals for the parameter values. </li><li><code>fontsize = 23</code>: Font size for the plots (to be used in <a href="@ref"><code>plot_aes!</code></a>).</li><li><code>x_scale = 1.0</code>: Value used for scaling the spatial data (and all other length units, e.g. for diffusion).</li><li><code>t_scale = 1.0</code>: Value used for scaling the temporal data (and all other time units, e.g. for reaction).</li></ul><p><strong>Outputs</strong></p><ul><li><code>delayCurvePlots</code>: A plot containing the learned functional form for the delay function, along with an uncertainty ribbon.</li><li><code>diffusionCurvePlots</code>: A plot containing the learned functional form for the diffusion function, along with an uncertainty ribbon.</li><li><code>reactionCurvePlots</code>: A plot containing the learned functional form for the reaction function, along with an uncertainty ribbon.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/plot_results.jl#L208-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.curve_values-Tuple{BootResults}" href="#EquationLearning.curve_values-Tuple{BootResults}"><code>EquationLearning.curve_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">curve_values(bgp::BootResults; &lt;keyword arguments&gt;)</code></pre><p>Computes values for plotting the learned functional forms along with confidence intervals for the bootstrapping results in <code>bgp</code>.</p><p><strong>Arguments</strong></p><ul><li><code>bgp</code>: A <a href="ref.html#EquationLearning.BootResults"><code>BootResults</code></a> object which contains the results for the bootstrapping. </li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>level = 0.05</code>: The significance level for computing the credible intervals for the parameter values. </li><li><code>x_scale = 1.0</code>: Value used for scaling the spatial data (and all other length units, e.g. for diffusion).</li><li><code>t_scale = 1.0</code>: Value used for scaling the temporal data (and all other time units, e.g. for reaction).</li></ul><p><strong>Outputs</strong></p><ul><li><code>Tu_vals</code>: Ribbon features for the delay functions. </li><li><code>Du_vals</code>: Ribbon features for the diffusion functions.</li><li><code>Ru_vals</code>: Ribbon features for the reaction functions.</li><li><code>u_vals</code>: The density values used for computing the functions. </li><li><code>t_vals</code>: The time values used for computing the functions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/plot_results.jl#L158-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.delay_product-Tuple{Any, Any}" href="#EquationLearning.delay_product-Tuple{Any, Any}"><code>EquationLearning.delay_product</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delay_product(bgp, t; type = &quot;diffusion&quot;, level = 0.05, x_scale = 1.0, t_scale = 1.0)</code></pre><p>Computes the curve <code>T(t; α)D(u; β)</code> (if <code>type = &quot;diffusion&quot;</code>) or <code>T(t; β)R(u; γ)</code> (if <code>type = &quot;reaction&quot;</code>) with uncertainty for the results in <code>bgp</code>, at the time <code>t</code>. The significance level is determined by <code>level</code> (<code>0.05</code> default) and the spatial and temporal data are scaled by <code>x_scale</code> (<code>1.0</code> default) and <code>t_scale</code> (<code>1.0</code> default), respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/plot_results.jl#L328-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.density_results-Tuple{BootResults}" href="#EquationLearning.density_results-Tuple{BootResults}"><code>EquationLearning.density_results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">density_results(bgp::BootResults; &lt;keyword arguments&gt;)</code></pre><p>Plots the densities for the bootstrapping results in <code>bgp</code>.</p><p><strong>Arguments</strong></p><ul><li><code>bgp</code>: A <a href="ref.html#EquationLearning.BootResults"><code>BootResults</code></a> object which contains the results for the bootstrapping. </li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>level = 0.05</code>: The significance level for computing the credible intervals for the parameter values. </li><li><code>fontsize = 23</code>: Font size for the plots (to be used in <a href="@ref"><code>plot_aes!</code></a>).</li><li><code>delay_scales = nothing</code>: Values that multiply the individual delay parameters.</li><li><code>diffusion_scales = nothing</code>: Values that multiply the individual diffusion parameters. </li><li><code>reaction_scales = nothing</code>: Values that multiply the individual reaction parameters.</li><li><code>diffusion_resolution = (800, 800)</code>: Resolution for the diffusion figure.</li><li><code>reaction_resolution = (800, 800)</code>: Resolution for the reaction figure.</li><li><code>delay_resolution = (800, 800)</code>: Resolution for the delay fgure.</li></ul><p><strong>Outputs</strong></p><ul><li><code>delayDensityFigure</code>: A figure of plots containing a density plot for each delay parameter.</li><li><code>diffusionDensityFigure</code>: A figure of plots containing a density plot for each diffusion parameter.</li><li><code>reactionDensityFigure</code>: A figure of plots containing a density plot for each reaction parameter.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/plot_results.jl#L84-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.density_values-Tuple{BootResults}" href="#EquationLearning.density_values-Tuple{BootResults}"><code>EquationLearning.density_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">density_values(bgp::BootResults; &lt;keyword arguments&gt;)</code></pre><p>Computes the densities for the bootstrapping results in <code>bgp</code>.</p><p><strong>Arguments</strong></p><ul><li><code>bgp</code>: A <a href="ref.html#EquationLearning.BootResults"><code>BootResults</code></a> object which contains the results for the bootstrapping. </li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>level = 0.05</code>: The significance level for computing the credible intervals for the parameter values. </li><li><code>fontsize = 23</code>: Font size for the plots (to be used in <a href="@ref"><code>plot_aes!</code></a>).</li><li><code>delay_scales = nothing</code>: Values that multiply the individual delay parameters.</li><li><code>diffusion_scales = nothing</code>: Values that multiply the individual diffusion parameters. </li><li><code>reaction_scales = nothing</code>: Values that multiply the individual reaction parameters.</li></ul><p><strong>Outputs</strong></p><ul><li><code>trv</code>: Delay densities.</li><li><code>dr</code>: Diffusion densities. </li><li><code>rr</code>: Reaction densities. </li><li><code>tt</code>: Number of delay parameters.</li><li><code>d</code>: Number of diffusion parameters.</li><li><code>r</code>: Number of reaction parameters. </li><li><code>delayCIs</code>: Confidence intervals for the delay parameters. </li><li><code>diffusionCIs</code>: Confidence intervals for the diffusion parameters. </li><li><code>reactionCIS</code>: Confidence intervals for the reaction parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/plot_results.jl#L9-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.pde_results-Tuple{Any, Any, Any, Any, Union{BasisBootResults, BootResults}}" href="#EquationLearning.pde_results-Tuple{Any, Any, Any, Any, Union{BasisBootResults, BootResults}}"><code>EquationLearning.pde_results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pde_results(x_pde, t_pde u_pde, solns_all, bgp::Union{BootResults, BasisBootResults}; &lt;keyword arguments&gt;)</code></pre><p>Plots the solutions to the PDEs corresponding to the bootstrap samples of <a href="ref.html#EquationLearning.bootstrap_gp"><code>bootstrap_gp</code></a> using  the computed solutins in <a href="ref.html#EquationLearning.boot_pde_solve"><code>boot_pde_solve</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>x_pde</code>: The spatial data to plot as points.</li><li><code>t_pde</code>: The temporal data to plot as points.</li><li><code>u_pde</code>: The density data to plot as points. </li><li><code>solns_all</code>: The solutions to the PDEs for each bootstrap iteration. </li><li><code>bgp::Union{BootResults, BasisBootResults}</code>: A <a href="ref.html#EquationLearning.BootResults"><code>BootResults</code></a> or <a href="ref.html#EquationLearning.BasisBootResults"><code>BasisBootResults</code></a> struct containing the results from <a href="ref.html#EquationLearning.bootstrap_gp"><code>bootstrap_gp</code></a> or <a href="ref.html#EquationLearning.basis_bootstrap_gp"><code>basis_bootstrap_gp</code></a>, respectively.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>colors = [:black, :blue, :red, :magenta, :green]</code>: A list of colors for colouring the solutions at each time.</li><li><code>level = 0.05</code>: The significance level for computing the credible intervals for the parameter values. </li><li><code>fontsize = 23</code>: Font size for the plots (to be used in <a href="@ref"><code>plot_aes!</code></a>).</li><li><code>x_scale = 1.0</code>: Value used for scaling the spatial data (and all other length units, e.g. for diffusion).</li><li><code>t_scale = 1.0</code>: Value used for scaling the temporal data (and all other time units, e.g. for reaction).`</li></ul><p><strong>Outputs</strong></p><ul><li><code>pdeSolutionPlots_BGP</code>: The plot of the PDE solutions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/plot_results.jl#L283-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.pde_values-Tuple{Any, Union{BasisBootResults, BootResults}}" href="#EquationLearning.pde_values-Tuple{Any, Union{BasisBootResults, BootResults}}"><code>EquationLearning.pde_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function pde_values(solns_all, bgp::Union{BootResults, BasisBootResults}; level = 0.05)</code></pre><p>Plots the solutions to the PDEs corresponding to the bootstrap samples of <a href="ref.html#EquationLearning.bootstrap_gp"><code>bootstrap_gp</code></a> using  the computed solutins in <a href="ref.html#EquationLearning.boot_pde_solve"><code>boot_pde_solve</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>solns_all</code>: The solutions to the PDEs for each bootstrap iteration. </li><li><code>bgp::Union{BootResults, BasisBootResults}</code>: Bootstrapping results.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>level = 0.05</code>: The significance level for computing the credible intervals for the parameter values. </li></ul><p><strong>Outputs</strong></p><ul><li><code>soln_vals_mean</code>: Mean solution values. </li><li><code>soln_vals_lowers</code>: Lower confidence interval for solution values.</li><li><code>soln_vals_upper</code>: Upper confidence interval for solution values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/plot_results.jl#L253-L270">source</a></section></article><h2 id="synthetic_data.jl"><a class="docs-heading-anchor" href="#synthetic_data.jl">synthetic_data.jl</a><a id="synthetic_data.jl-1"></a><a class="docs-heading-anchor-permalink" href="#synthetic_data.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.generate_data-NTuple{12, Any}" href="#EquationLearning.generate_data-NTuple{12, Any}"><code>EquationLearning.generate_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_data(x₀, u₀, T, D, R, α, β, γ, δt, finalTime; &lt;keyword arguments&gt;)</code></pre><p>Generate synthetic data from values <code>(x₀, t₀)</code> at <code>t = 0</code> with exact mechanisms <code>T</code>, <code>D</code>, and <code>R</code> for delay, diffusion, and reaction, respectively. </p><p><strong>Arguments</strong></p><ul><li><code>x₀</code>: The spatial mesh for points at <code>t = 0</code>.</li><li><code>u₀</code>: The density values at <code>t = 0</code> corresponding to the points in <code>x₀</code>.</li><li><code>T</code>: A delay function of the form <code>T(t, α, T_params)</code>.</li><li><code>D</code>: A diffusion function of the form <code>D(u, β, D_params)</code>.</li><li><code>R</code>: A reaction function of the form <code>R(u, γ, R_params)</code>.</li><li><code>D′</code>: The derivative of the diffusion function, given in the form <code>D′(u, β, D_params)</code>.</li><li><code>R′</code>: The reaction function, given in the form <code>R(u, γ, R_params)</code>.</li><li><code>α</code>: Exact values for the delay parameters.</li><li><code>β</code>: Exact values for the diffusion parameters.</li><li><code>γ</code>: Exact values for the reaction parameters. </li><li><code>δt</code>: Times to save the solution to the differential equations at for generating the data.</li><li><code>finalTime</code>: The time to solve the differential equations up to.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>N = 1000</code>: The number of mesh points to use.</li><li><code>LHS = [0.0, 1.0, 0.0]</code>: Vector defining the left-hand boundary conditions for the PDE. See also the definitions of <code>(a₀, b₀, c₀)</code> in <a href="index.html#EquationLearning.sysdegeneral!-NTuple{4, Any}"><code>sysdegeneral!</code></a>.</li><li><code>RHS = [0.0, -1.0, 0.0]</code>: Vector defining the right-hand boundary conditions for the PDE. See also the definitions of <code>(a₁, b₁, c₁)</code> in <a href="index.html#EquationLearning.sysdegeneral!-NTuple{4, Any}"><code>sysdegeneral!</code></a>.</li><li><code>alg = nothing</code>: The algorithm to use for solving the differential equations.</li><li><code>N_thin = 100</code>: The number of points to take from the solution at each time.</li><li><code>num_restarts = 50</code>: The number of times to restart the optimiser for fitting the Gaussian process to the data.</li><li><code>D_params</code>: Additional known parameters for the diffusion function.</li><li><code>R_params</code>: Additional known parameters for the reaction function.</li><li><code>T_params</code>: Additional known parameters for the delay function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/synthetic_data.jl#L8-L38">source</a></section></article><h2 id="utils.jl"><a class="docs-heading-anchor" href="#utils.jl">utils.jl</a><a id="utils.jl-1"></a><a class="docs-heading-anchor-permalink" href="#utils.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.compute_ribbon_features-Tuple{Any}" href="#EquationLearning.compute_ribbon_features-Tuple{Any}"><code>EquationLearning.compute_ribbon_features</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_ribbon_features(x; level = 0.05)</code></pre><p>Computes features for a confidence interval plot for some data <code>x</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The data to use for plotting.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>level = 0.05</code>: The significance level for computing the credible intervals for the parameter values. </li></ul><p><strong>Outputs</strong></p><ul><li><code>x_mean</code>: The mean of each row of <code>x</code>.</li><li><code>x_lower</code>: The <code>100(</code>level/2<code>)%</code> quantile for each row of <code>x</code>.</li><li><code>x_upper</code>: The <code>100(</code>1-level/2<code>)%</code> quantile for each row of <code>x</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/utils.jl#L89-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.data_thresholder-Tuple{Any, Any, Any}" href="#EquationLearning.data_thresholder-Tuple{Any, Any, Any}"><code>EquationLearning.data_thresholder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">data_thresholder(f, fₜ, τ)</code></pre><p>Thresholds the data given by <code>f</code> with temporal derivatives <code>fₜ</code> based on a threshold tolerance <code>τ</code>. The returned values  in <code>inIdx</code> give the indices in <code>f</code> (and <code>fₜ</code>) that should be kept. </p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Computed values of <code>f(x, t)</code>.</li><li><code>fₜ</code>: Computed values of <code>fₜ(x, t)</code>.</li><li><code>τ</code>: A tuple of the form <code>(τ₁, τ₂)</code> which gives the tolerance <code>τ₁</code> for thresholding <code>f</code> and <code>τ₂</code> for thresholding <code>fₜ</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>inIdx</code>: Indices in <code>f</code> (and <code>fₜ</code>) that should be kept.</li></ul><p><strong>Extended help</strong></p><p>The threshold conditions are:</p><pre><code class="nohighlight hljs">1. `min(|f|)τ₁ ≤ |f| ≤ max(|f|)(1-τ₁)`.
2. `min(|fₜ|)τ₂ ≤ |fₜ| ≤ max(|fₜ|)(1-τ₂)`.
3. `f ≥ 0.0`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/utils.jl#L58-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.scale_unit-Tuple{Any}" href="#EquationLearning.scale_unit-Tuple{Any}"><code>EquationLearning.scale_unit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scale_unit(x)</code></pre><p>Scales the data in <code>x</code> such that <code>x ∈ [0, 1]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: The data to be scaled. </li></ul><p><strong>Outputs</strong></p><ul><li><code>xx</code>: The scaled data such that <code>xx ∈ [0, 1]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/utils.jl#L8-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.searchsortednearest-Tuple{Any, Any}" href="#EquationLearning.searchsortednearest-Tuple{Any, Any}"><code>EquationLearning.searchsortednearest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">searchsortednearest(a, x; &lt;keyword arguments&gt;)</code></pre><p>Finds the index in <code>a</code> that has the smallest <code>distance</code> to <code>x</code>. Ties go to the smallest index.</p><p><em>Source</em>: Taken from https://github.com/joshday/SearchSortedNearest.jl/blob/main/src/SearchSortedNearest.jl.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: A sorted collection.</li><li><code>x</code>: A value which is used for comparing the values of <code>a</code> to for finding the closest value.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>by = identity</code>: The order in which <code>a</code> is sorted. If <code>a</code> is sorted, this is just <code>identity</code>.</li><li><code>lt = isless</code>: The metric used for sorting values in <code>a</code>, typically <code>lt = isless</code> which uses <code>&lt;</code>.</li><li><code>rev = false</code>: Whether to reverse the array <code>a</code>.</li><li><code>distance = (a, b) -&gt; abs(a - b)</code>: The distance metric used for assessing which value is closest.</li></ul><p><strong>Outputs</strong></p><ul><li><code>i</code>: The index such that <code>distance(a[i], a)</code> is minimised.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/utils.jl#L26-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="EquationLearning.update_results-Tuple{Any, Any, Any}" href="#EquationLearning.update_results-Tuple{Any, Any, Any}"><code>EquationLearning.update_results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_results(bgp, bgp_new, mechanism)</code></pre><p>Updates the results in <code>bgp</code> with new results <code>bgp_new</code> for a re-estimated <code>mechanism</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DanielVandH/EquationLearning.jl/blob/ed115057537b8b3ed1c45217f8665a5af4411a7b/src/utils.jl#L112-L116">source</a></section></article><h2 id="Links"><a class="docs-heading-anchor" href="#Links">Links</a><a id="Links-1"></a><a class="docs-heading-anchor-permalink" href="#Links" title="Permalink"></a></h2><ul><li><a href="ref.html#EquationLearning.AllResults"><code>EquationLearning.AllResults</code></a></li><li><a href="ref.html#EquationLearning.BasisBootResults"><code>EquationLearning.BasisBootResults</code></a></li><li><a href="ref.html#EquationLearning.BootResults"><code>EquationLearning.BootResults</code></a></li><li><a href="ref.html#EquationLearning.Bootstrap_Setup"><code>EquationLearning.Bootstrap_Setup</code></a></li><li><a href="ref.html#EquationLearning.GP_Setup"><code>EquationLearning.GP_Setup</code></a></li><li><a href="ref.html#EquationLearning.PDE_Setup"><code>EquationLearning.PDE_Setup</code></a></li><li><a href="index.html#EquationLearning.AIC-Tuple{Union{BasisBootResults, BootResults}, Any, Any, Any}"><code>EquationLearning.AIC</code></a></li><li><a href="ref.html#EquationLearning.AIC"><code>EquationLearning.AIC</code></a></li><li><a href="ref.html#EquationLearning.basis_bootstrap_gp"><code>EquationLearning.basis_bootstrap_gp</code></a></li><li><a href="index.html#EquationLearning.basis_bootstrap_gp-Union{Tuple{T1}, Tuple{T1, T1, T1, Vector{Function}, Vector{Function}, Vector{Function}, Vector{Function}}} where T1&lt;:(AbstractVector)"><code>EquationLearning.basis_bootstrap_gp</code></a></li><li><a href="index.html#EquationLearning.basis_bootstrap_helper-NTuple{7, Any}"><code>EquationLearning.basis_bootstrap_helper</code></a></li><li><a href="index.html#EquationLearning.basis_learn_equations!-NTuple{15, Any}"><code>EquationLearning.basis_learn_equations!</code></a></li><li><a href="index.html#EquationLearning.basis_sysdegeneral!-NTuple{4, Any}"><code>EquationLearning.basis_sysdegeneral!</code></a></li><li><a href="index.html#EquationLearning.boot_pde_solve-Tuple{BootResults, Any, Any, Any}"><code>EquationLearning.boot_pde_solve</code></a></li><li><a href="index.html#EquationLearning.boot_pde_solve-Tuple{BasisBootResults, Any, Any, Any}"><code>EquationLearning.boot_pde_solve</code></a></li><li><a href="ref.html#EquationLearning.boot_pde_solve"><code>EquationLearning.boot_pde_solve</code></a></li><li><a href="index.html#EquationLearning.bootstrap_gp-Union{Tuple{T1}, Tuple{T1, T1, T1, Function, Function, Function, Function, Function, T1, T1, T1, T1, T1}} where T1&lt;:(AbstractVector)"><code>EquationLearning.bootstrap_gp</code></a></li><li><a href="ref.html#EquationLearning.bootstrap_gp"><code>EquationLearning.bootstrap_gp</code></a></li><li><a href="index.html#EquationLearning.bootstrap_grid-NTuple{4, Any}"><code>EquationLearning.bootstrap_grid</code></a></li><li><a href="index.html#EquationLearning.bootstrap_helper-NTuple{16, Any}"><code>EquationLearning.bootstrap_helper</code></a></li><li><a href="index.html#EquationLearning.bootstrap_helper-Tuple{Any, Any, Any, Any, Any, Any, Any, GP_Setup, Bootstrap_Setup, PDE_Setup, Any}"><code>EquationLearning.bootstrap_helper</code></a></li><li><a href="index.html#EquationLearning.check_constraints-Tuple{Any, Any}"><code>EquationLearning.check_constraints</code></a></li><li><a href="index.html#EquationLearning.check_constraints-Tuple{Any, Function, Function, Function, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}"><code>EquationLearning.check_constraints</code></a></li><li><a href="index.html#EquationLearning.classify_Δᵢ-Tuple{Float64}"><code>EquationLearning.classify_Δᵢ</code></a></li><li><a href="index.html#EquationLearning.compare_AICs-Tuple{Vararg{Vector{Float64}}}"><code>EquationLearning.compare_AICs</code></a></li><li><a href="ref.html#EquationLearning.compare_AICs"><code>EquationLearning.compare_AICs</code></a></li><li><a href="index.html#EquationLearning.compare_AICs-Tuple{Vararg{Float64}}"><code>EquationLearning.compare_AICs</code></a></li><li><a href="index.html#EquationLearning.compare_AICs-Tuple{Any, Any, Any, Vararg{Union{BasisBootResults, BootResults}}}"><code>EquationLearning.compare_AICs</code></a></li><li><a href="index.html#EquationLearning.compute_initial_conditions-Tuple{Any, Any, Any, Union{BasisBootResults, BootResults}, Any}"><code>EquationLearning.compute_initial_conditions</code></a></li><li><a href="index.html#EquationLearning.compute_initial_conditions-Tuple{Any, Any, Any, Any, Union{BasisBootResults, BootResults}, Any, Any, Any}"><code>EquationLearning.compute_initial_conditions</code></a></li><li><a href="ref.html#EquationLearning.compute_joint_GP"><code>EquationLearning.compute_joint_GP</code></a></li><li><a href="index.html#EquationLearning.compute_joint_GP-Tuple{GaussianProcesses.GPBase, Any}"><code>EquationLearning.compute_joint_GP</code></a></li><li><a href="index.html#EquationLearning.compute_ribbon_features-Tuple{Any}"><code>EquationLearning.compute_ribbon_features</code></a></li><li><a href="index.html#EquationLearning.compute_valid_pde_indices-Tuple{Any, Any, Any, Any, BasisBootResults}"><code>EquationLearning.compute_valid_pde_indices</code></a></li><li><a href="index.html#EquationLearning.compute_valid_pde_indices-Tuple{Any, Any, Any, Any, Any, BootResults}"><code>EquationLearning.compute_valid_pde_indices</code></a></li><li><a href="index.html#EquationLearning.compute_valid_pde_indices-Tuple{BasisBootResults, Any, Any, Any, Any, Any, Any, Any, Any, Any}"><code>EquationLearning.compute_valid_pde_indices</code></a></li><li><a href="index.html#EquationLearning.compute_valid_pde_indices-Tuple{BootResults, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}"><code>EquationLearning.compute_valid_pde_indices</code></a></li><li><a href="index.html#EquationLearning.curve_results-Tuple{BootResults}"><code>EquationLearning.curve_results</code></a></li><li><a href="index.html#EquationLearning.curve_results-Tuple{BasisBootResults}"><code>EquationLearning.curve_results</code></a></li><li><a href="ref.html#EquationLearning.curve_results"><code>EquationLearning.curve_results</code></a></li><li><a href="index.html#EquationLearning.curve_values-Tuple{BootResults}"><code>EquationLearning.curve_values</code></a></li><li><a href="index.html#EquationLearning.curve_values-Tuple{BasisBootResults}"><code>EquationLearning.curve_values</code></a></li><li><a href="ref.html#EquationLearning.curve_values"><code>EquationLearning.curve_values</code></a></li><li><a href="index.html#EquationLearning.data_thresholder-Tuple{Any, Any, Any}"><code>EquationLearning.data_thresholder</code></a></li><li><a href="ref.html#EquationLearning.delay_product"><code>EquationLearning.delay_product</code></a></li><li><a href="index.html#EquationLearning.delay_product-Tuple{Any, Any}"><code>EquationLearning.delay_product</code></a></li><li><a href="index.html#EquationLearning.density_results-Tuple{BootResults}"><code>EquationLearning.density_results</code></a></li><li><a href="ref.html#EquationLearning.density_results"><code>EquationLearning.density_results</code></a></li><li><a href="index.html#EquationLearning.density_results-Tuple{BasisBootResults}"><code>EquationLearning.density_results</code></a></li><li><a href="ref.html#EquationLearning.density_values"><code>EquationLearning.density_values</code></a></li><li><a href="index.html#EquationLearning.density_values-Tuple{BootResults}"><code>EquationLearning.density_values</code></a></li><li><a href="index.html#EquationLearning.density_values-Tuple{BasisBootResults}"><code>EquationLearning.density_values</code></a></li><li><a href="index.html#EquationLearning.dktᵢ-NTuple{6, Any}"><code>EquationLearning.dktᵢ</code></a></li><li><a href="index.html#EquationLearning.dktⱼ-NTuple{6, Any}"><code>EquationLearning.dktⱼ</code></a></li><li><a href="index.html#EquationLearning.dkxᵢ-NTuple{6, Any}"><code>EquationLearning.dkxᵢ</code></a></li><li><a href="index.html#EquationLearning.dkxⱼ-NTuple{6, Any}"><code>EquationLearning.dkxⱼ</code></a></li><li><a href="index.html#EquationLearning.draw_gp!-Tuple{Any, Any, LinearAlgebra.LowerTriangular, Any, Any}"><code>EquationLearning.draw_gp!</code></a></li><li><a href="index.html#EquationLearning.d²ktᵢtⱼ-NTuple{6, Any}"><code>EquationLearning.d²ktᵢtⱼ</code></a></li><li><a href="index.html#EquationLearning.d²ktᵢxⱼ-NTuple{6, Any}"><code>EquationLearning.d²ktᵢxⱼ</code></a></li><li><a href="index.html#EquationLearning.d²kxᵢ-NTuple{6, Any}"><code>EquationLearning.d²kxᵢ</code></a></li><li><a href="index.html#EquationLearning.d²kxᵢtⱼ-NTuple{6, Any}"><code>EquationLearning.d²kxᵢtⱼ</code></a></li><li><a href="index.html#EquationLearning.d²kxᵢxⱼ-NTuple{6, Any}"><code>EquationLearning.d²kxᵢxⱼ</code></a></li><li><a href="index.html#EquationLearning.d²kxⱼ-NTuple{6, Any}"><code>EquationLearning.d²kxⱼ</code></a></li><li><a href="index.html#EquationLearning.d³kxᵢxⱼ²-NTuple{6, Any}"><code>EquationLearning.d³kxᵢxⱼ²</code></a></li><li><a href="index.html#EquationLearning.d³kxᵢ²tⱼ-NTuple{6, Any}"><code>EquationLearning.d³kxᵢ²tⱼ</code></a></li><li><a href="index.html#EquationLearning.d³kxᵢ²xⱼ-NTuple{6, Any}"><code>EquationLearning.d³kxᵢ²xⱼ</code></a></li><li><a href="index.html#EquationLearning.d³tᵢxⱼ²-NTuple{6, Any}"><code>EquationLearning.d³tᵢxⱼ²</code></a></li><li><a href="index.html#EquationLearning.d⁴kxᵢ²xⱼ²-NTuple{6, Any}"><code>EquationLearning.d⁴kxᵢ²xⱼ²</code></a></li><li><a href="index.html#EquationLearning.error_comp-NTuple{5, Any}"><code>EquationLearning.error_comp</code></a></li><li><a href="ref.html#EquationLearning.error_comp"><code>EquationLearning.error_comp</code></a></li><li><a href="index.html#EquationLearning.evaluate_basis-NTuple{4, Any}"><code>EquationLearning.evaluate_basis</code></a></li><li><a href="index.html#EquationLearning.evaluate_basis!-NTuple{6, Any}"><code>EquationLearning.evaluate_basis!</code></a></li><li><a href="index.html#EquationLearning.fit_GP-Tuple{Any, Any, Any}"><code>EquationLearning.fit_GP</code></a></li><li><a href="ref.html#EquationLearning.fit_GP"><code>EquationLearning.fit_GP</code></a></li><li><a href="index.html#EquationLearning.fit_GP-Tuple{Any, Any, Any, GP_Setup}"><code>EquationLearning.fit_GP</code></a></li><li><a href="index.html#EquationLearning.generate_data-NTuple{12, Any}"><code>EquationLearning.generate_data</code></a></li><li><a href="ref.html#EquationLearning.generate_data"><code>EquationLearning.generate_data</code></a></li><li><a href="index.html#EquationLearning.learn_equations!-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Vararg{Any}}"><code>EquationLearning.learn_equations!</code></a></li><li><a href="index.html#EquationLearning.loss_function-Tuple{Any}"><code>EquationLearning.loss_function</code></a></li><li><a href="index.html#EquationLearning.opt_restart!-NTuple{5, Any}"><code>EquationLearning.opt_restart!</code></a></li><li><a href="ref.html#EquationLearning.pde_results"><code>EquationLearning.pde_results</code></a></li><li><a href="index.html#EquationLearning.pde_results-Tuple{Any, Any, Any, Any, Union{BasisBootResults, BootResults}}"><code>EquationLearning.pde_results</code></a></li><li><a href="index.html#EquationLearning.pde_values-Tuple{Any, Union{BasisBootResults, BootResults}}"><code>EquationLearning.pde_values</code></a></li><li><a href="ref.html#EquationLearning.pde_values"><code>EquationLearning.pde_values</code></a></li><li><a href="index.html#EquationLearning.preallocate_bootstrap-NTuple{6, Any}"><code>EquationLearning.preallocate_bootstrap</code></a></li><li><a href="index.html#EquationLearning.preallocate_eqlearn-NTuple{12, Any}"><code>EquationLearning.preallocate_eqlearn</code></a></li><li><a href="index.html#EquationLearning.precompute_gp_mean-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, Any, Bootstrap_Setup}"><code>EquationLearning.precompute_gp_mean</code></a></li><li><a href="ref.html#EquationLearning.precompute_gp_mean"><code>EquationLearning.precompute_gp_mean</code></a></li><li><a href="index.html#EquationLearning.scale_unit-Tuple{Any}"><code>EquationLearning.scale_unit</code></a></li><li><a href="index.html#EquationLearning.searchsortednearest-Tuple{Any, Any}"><code>EquationLearning.searchsortednearest</code></a></li><li><a href="index.html#EquationLearning.sysdegeneral!-NTuple{4, Any}"><code>EquationLearning.sysdegeneral!</code></a></li><li><a href="index.html#EquationLearning.update_results-Tuple{Any, Any, Any}"><code>EquationLearning.update_results</code></a></li><li><a href="ref.html#EquationLearning.update_results"><code>EquationLearning.update_results</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="ref.html">« Manual</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.16 on <span class="colophon-date" title="Saturday 23 April 2022 06:06">Saturday 23 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
