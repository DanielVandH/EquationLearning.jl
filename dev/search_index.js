var documenterSearchIndex = {"docs":
[{"location":"home.html#Equation-Learning","page":"Home","title":"Equation Learning","text":"","category":"section"},{"location":"home.html","page":"Home","title":"Home","text":"This package allows for the learning of mechanisms T(t mathbfalpha), D(u mathbfbeta), and R(u mathbfgamma) for  delay, diffusion, and reaction model, for some cell data u and points (x t), assuming that u satisfies the model","category":"page"},{"location":"home.html","page":"Home","title":"Home","text":"fracpartial upartial t = T(t mathbfalpha)leftfracpartialpartial xleft(D(u mathbfbeta)fracpartial upartial xright) + R(u mathbfgamma)right","category":"page"},{"location":"home.html","page":"Home","title":"Home","text":"The package fits a Gaussian process to the data u at these points (x t) and uses it to draw samples from, allowing for multiple estimates of the parameters mathbfalpha, mathbfbeta, and mathbfgamma to be obtained, thus providing uncertainty quantification for these learned mechanisms. See our paper ... for more details. The main function exported by this package is bootstrap_gp which actual fits a given model with uncertainty quantification.","category":"page"},{"location":"tut.html#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"Here we describe how the methods in this package can be used. We illustrate this on the 12,000 cells per well dataset from Jin et al. (2016). We only show how we could fit a delayed Fisher-Kolmogorov model. Instructions for fitting, for example, a model with the basis function approach can be found by looking at the corresponding code from our paper as described here. We start with the following:","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"# Packages\nusing EquationLearning      # Load our actual package \nusing DelimitedFiles        # For loading the density data of Jin et al. (2016).\nusing DataFrames            # For conveniently representing the data\nusing CairoMakie            # For creating plots\nusing LaTeXStrings          # For adding LaTeX labels to plots\nusing Random                # For setting seeds \nusing LinearAlgebra         # For setting number of threads to prevent StackOverflowError\nusing Setfield              # For modifying immutable structs\n# Plots and setup\ncolors = [:black, :blue, :red, :magenta, :green]\nLinearAlgebra.BLAS.set_num_threads(1)\n# Read in the data \nfunction prepare_data(filename) # https://discourse.julialang.org/t/failed-to-precompile-csv-due-to-load-error/70146/2\n    data, header = readdlm(filename, ',', header=true)\n    df = DataFrame(data, vec(header))\n    df_new = identity.(df)\n    return df_new\nend\nassay_data = Vector{DataFrame}([])\nx_scale = 1000.0 # μm ↦ mm \nt_scale = 24.0   # hr ↦ day \nfor i = 1:6\n    file_name = string(\"data/CellDensity_\", 10 + 2 * (i - 1), \".csv\") # This assumes that you are in the VandenHeuvel2022_Paper code folder of our repository. If the data is hosted somewhere else, simply change this line to locate the correct directory.\n    dat = prepare_data(file_name)\n    dat.Position = convert.(Float64, dat.Position)\n    dat.Time = convert.(Float64, dat.Time)\n    dat.Position ./= x_scale\n    dat.Dens1 .*= x_scale^2\n    dat.Dens2 .*= x_scale^2\n    dat.Dens3 .*= x_scale^2\n    dat.AvgDens .*= x_scale^2\n    dat.Time ./= t_scale\n    push!(assay_data, dat)\nend\nK = 1.7e-3 * x_scale^2 # Cell carrying capacity as estimated from Jin et al. (2016).\ndat = assay_data[2] # The data we will be using in this tutorial","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"For this data we also need to extract x, t, u, and the values to use for the PDEs:","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"x = repeat(dat.Position, outer=3)\nt = repeat(dat.Time, outer=3)\nu = vcat(dat.Dens1, dat.Dens2, dat.Dens3)\nx_pde = dat.Position\nt_pde = dat.Time\nu_pde = dat.AvgDens","category":"page"},{"location":"tut.html#PDE-parameters","page":"Tutorial","title":"PDE parameters","text":"","category":"section"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"The first step is to define the PDE setup. Our function needs a PDE_Setup struct from the following function:","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"struct PDE_Setup\n    meshPoints::AbstractVector     \n    LHS::Vector{Float64}\n    RHS::Vector{Float64}\n    finalTime::Float64\n    δt::AbstractVector\n    alg\nend","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"The field meshPoints gives the grid points for the discretised PDE, LHS gives the coefficients in the boundary condition a_0u(a t) - b_0partial u(a t)partial x = c_0, RHS gives the coefficients in the boundary condition a_1u(b t) + b_1partial u(b t)partial x = c_1, finalTime gives the time that the solution is solved up to, δt gives the vector of points to return the solution at, and alg gives the algorithm to use for solving the system of ODEs arising from the discretised PDE. We use the following:","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"δt = LinRange(0.0, 48.0 / t_scale, 5)\nfinalTime = 48.0 / t_scale\nN = 500\nLHS = [0.0, 1.0, 0.0]\nRHS = [0.0, -1.0, 0.0]\nalg = Tsit5()\nmeshPoints = LinRange(75.0 / x_scale, 1875.0 / x_scale, N)\npde_setup = PDE_Setup(meshPoints, LHS, RHS, finalTime, δt, alg)","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"Note that these boundary conditions LHS and RHS correspond to no flux boundary conditions. For PDE_Setup we also provide a constructor with defaults:","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"meshPoints = LinRange(extrema(x)..., 500).\nLHS = [0.0, 1.0, 0.0].\nRHS = [0.0, -1.0, 0.0].\nfinalTime = maximum(t).\nδt = finalTime / 4.0.\nalg = nothing.","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"See the manual for more details.","category":"page"},{"location":"tut.html#Bootstrapping-parameters","page":"Tutorial","title":"Bootstrapping parameters","text":"","category":"section"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"The next step is to define the parameters for bootstrapping. The following struct is used for these parameters:","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"struct Bootstrap_Setup\n    bootₓ::AbstractVector\n    bootₜ::AbstractVector\n    B::Int\n    τ::Tuple{Float64,Float64}\n    Optim_Restarts::Int\n    constrained::Bool\n    obj_scale_GLS::Function\n    obj_scale_PDE::Function\n    init_weight::Float64\n    show_losses::Bool\nend","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"The bootₓ field gives the spatial grid for bootstrapping, bootₜ the spatial grid for bootstrapping, B the number of bootstrap iterations, τ the two threshold parameters for data thresholding, Optim_Restarts the number of the times the optimiser should be restarted, constrained an indicator for whether the optimisation problem should be constrained, obj_scale_GLS the transformation to apply to the GLS loss function, obj_scale_PDE the transformation to apply to the PDE loss function, init_weight the weighting to apply in the GLS loss function to the data at t = 0, and show_losses an indicator for whether the losses should be printed to the REPL at each stage of the optimiser.","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"For this problem we will use n = m = 50 points in space and time for the bootstrapping grid, and 100 bootstrap iterations with no optimiser restarts. We do not constrain the parameter estimates. To put the loss functions on roughly the same scale we will apply a log transformation to each individual loss function. We weight the data at t=0 by a factor of 10, and we do not show the losses in the REPL. We set this up as follows:","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"nₓ = 50\nnₜ = 50\nbootₓ = LinRange(75.0 / x_scale, 1875.0 / x_scale, nₓ)\nbootₜ = LinRange(0.0, 48.0 / t_scale, nₜ)\nB = 100\nτ = (0.0, 0.0)\nOptim_Restarts = 1\nconstrained = false\nobj_scale_GLS = log\nobj_scale_PDE = log\ninit_weight = 10.0\nshow_losses = false\nbootstrap_setup = Bootstrap_Setup(bootₓ, bootₜ, B, τ, Optim_Restarts, constrained, obj_scale_GLS, obj_scale_PDE, init_weight, show_losses)","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"This struct also have a constructor, for which the defaults are:","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"bootₓ = LinRange(extrema(x)..., 80)\nbootₜ = LinRange(extrema(t)..., 80).\nB = 100.\nτ = (0.0, 0.0).\nOptim_Restarts = 5.\nconstrained = false.\nobj_scale_GLS = x -> x.\nobj_scale_PDE = x -> x.\ninit_weight = 10.0.\nshow_losses = false.","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"See the manual for more details.","category":"page"},{"location":"tut.html#Gaussian-process-parameters","page":"Tutorial","title":"Gaussian process parameters","text":"","category":"section"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"The Gaussian process parameters are setup in the GP_Setup struct, defined as:","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"struct GP_Setup\n    ℓₓ::Vector{Float64}\n    ℓₜ::Vector{Float64}\n    σ::Vector{Float64}\n    σₙ::Vector{Float64}\n    GP_Restarts::Int\n    μ::Union{Missing,Vector{Float64}}\n    L::Union{Missing,LowerTriangular{Float64}}\n    nugget::Float64\n    gp::Union{Missing,GPBase}\nend","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"The ℓₓ field gives a vector defining the interval to sample the spatial length scales between, ℓₜ the vector defining the interval to sample the spatial length scales between, σ the standard deviation of the noise-free data, σₙ the standard deviation of the noise, GP_Restarts the number of time to refit the Gaussian process to improve the hyperparameter estimates, μ the mean vector of the Gaussian process and derivatives (or missing if it should be computed in bootstrap_gp itself), L the Cholesky vector of the Gaussian process and derivatives (or missing if it should be computed in bootstrap_gp itself), nugget the nugget term for regularising the covariance matrix such that it is symmetric positive definite, and gp the fitted Gaussian process for just the cell density (or missing if it should be computed in bootstrap_gp itself).","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"Since we scale the data to be between 0 and 1 when fitting the Gaussian process, we pick our length scales to be between 0 and 1; these length scales must be defined on a log scale due to how they are defined in GaussianProcesses.jl. The values for the standard deviations are less clear and so we will choose it to be small, and also base it on the standard deviation of the observed data. A reasonably small nugget value needs to be used. Moreover, we can use many optimiser restarts since the Gaussian processes are not too expensive to fit. This leads to the following parameters:","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"ℓₓ = log.([1e-6, 1.0])\nℓₜ = log.([1e-6, 1.0])\nnugget = 1e-5\nGP_Restarts = 250\nσ = log.([1e-6, 7std(u)])\nσₙ = log.([1e-6, 7std(u)])\ngp, μ, L = EquationLearning.precompute_gp_mean(x, t, u, ℓₓ, ℓₜ, σ, σₙ, nugget, GP_Restarts, bootstrap_setup)\ngp_setup = GP_Setup(u; ℓₓ, ℓₜ, σ, σₙ, GP_Restarts, μ, L, nugget, gp)","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"This struct GP_Setup also has a constructor with the following defaults:","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"ℓₓ = log.([1e-6, 1.0]).\nℓₜ = log.([1e-6, 1.0]).\nσ = log.([1e-6, 7std(u)]).\nσₙ = log.([1e-6, 7std(u)]).\nGP_Restarts = 50.\nμ = missing.\nL = missing.\nnugget = 1e-4.\ngp = missing.","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"See the manual for more details.","category":"page"},{"location":"tut.html#Defining-the-functions","page":"Tutorial","title":"Defining the functions","text":"","category":"section"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"Now we want to define the functions and the corresponding parameter scales. Remember that the model we want to fit takes the form","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"fracpartial upartial t = T(t mathbfalpha)leftleft(D(u mathbfbeta)fracpartial upartial xright) + R(u mathbfgamma)right","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"where ","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"T(t mathbfalpha) = frac11+exp(-alpha_1-alpha_2t) quad D(u mathbfalpha) = beta_1 quad R(u mathbfgamma) = gamma_1uleft(1-fracuKright)","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"The function bootstrap_gp assumes that T, D, and R are given as functions of (t mathbfalpha mathbfp), (u mathbfbeta mathbfp), and (u mathbfgamma mathbfp), respectively. This vector mathbfp gives a vector of known parameters for each of the functions, and is used to allow for type stability in the functions. In particular, it would be wrong to define the reaction function as","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"R = (u, γ, p) -> γ[1] * u * (1.0 - u / K)","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"since K is in the scope of the main Julia REPL rather than the function itself, potentially leading to problems with type stability and making the function significantly slower. With this in mind, we define our functions as follows:","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"T = (t, α, p) -> 1.0 / (1.0 + exp(-α[1] * p[1] - α[2] * p[2] * t))\nD = (u, β, p) -> β[1] * p[1]\nR = (u, γ, p) -> γ[1] * p[2] * u * (1.0 - u / p[1])\nD′ = (u, β, p) -> 0.0\nR′ = (u, γ, p) -> γ[1] * p[2] - 2.0 * γ[1] * p[2] * u / p[1]","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"The derivative for the reaction term is not currently used, but in the future it may be used and we thus include it as a necessary term in bootstrap_gp, hence its presence here. In these functions we give each parameter a corresponding value in the vector mathbfp, which we can use to put the parameters on the same scale. To now think about defining mathbfp, we could set the parameter scales to be 1 and fit a small number of models, as described in great detail in the first simulation study of our paper. We will instead provide a way that should typically good enough (that is only specific to this dataset since there already exist papers that study this data). In Table 1 of Jin et al. (2016), the values for beta_1 and gamma_1 are given as 250 pm 140 and 0044 pm 0002, respectively, in units of mutextrmm^2textrmh^-1 and textrmh^-1, respectively. The delay term should not, affect these estimates so significantly, although we do not expect to get these exact same parameter values, so we should not scale the parameters with exactly these values. Similarly, although they consider a different form of the model, Lagergren et al. (2020) present the same delay model for this dataset, finding alpha_1 = -33013 and beta_2 = 02293 (textrmhr^-1). Based on these estimates, and with some other configuring with these estimates (after running the model for a small number of models to further improve these estimates in a significantly faster time than if we simply started with unit parameter scales), we define the following parameters:","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"T_params = [-1.6, 0.2 * t_scale]\nD_params = [160.0 * t_scale / x_scale^2]\nR_params = [K, 0.057 * t_scale]","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"Note that we multiply by t_scale and x_scale so that we shift the parameters into the correct units.","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"The remaining required arguments in bootstrap_gp are the bounds on parameters, and placeholder vectors for the number of parameters to estimate for each mechanism. For these latter arguments, we simply define:","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"α₀ = [1.0, 1.0]\nβ₀ = [1.0]\nγ₀ = [1.0]","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"The values do not matter, they just have to have the same values. For the parameter bounds, these do not matter since we will not be doing any optimiser restarts. (These bounds are not constraints on the parameters since we have constrained = false; in this case they simply define the hypercube for the Latin hypercube sampler to use for sampling parameter estimates.) We still have to provide both in this case. When we use a single optimiser restart, the initial value used in the optimiser is the middle of the given parameter bounds. Since we scale the parameters to all (hopefully) be mathcal O(1), we start each parameter at 1:","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"lowers = [0.99, 0.99, 0.99, 0.99]\nuppers = [1.01, 1.01, 1.01, 1.01]","category":"page"},{"location":"tut.html#Fitting-the-model","page":"Tutorial","title":"Fitting the model","text":"","category":"section"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"We now fit the model. (Since we are not going to be performing any model comparisons in this paper, we do not provide a zvals argument; see how we use this argument for model comparison in VandenHeuvel2022PaperCode/papercode.jl by first defining a zvals vector and then using zvals = zvals in bootstrap_gp. These zvals are also provided in the struct for the final results, so we could instead not provide them and simply reuse the zvals from the first model.) We call the function as:","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"bgp = bootstrap_gp(x, t, u, T, D, D′, R, R′, α₀, β₀, γ₀, lowers, uppers; gp_setup, bootstrap_setup, optim_setup, pde_setup, D_params, R_params, T_params, verbose=false)","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"The verbose=false argument is used to prevent any spam from the differential equations solver in the REPL in case the parameters enter a region where all the solutions become unstable (which it will eventually exit out of and give reasonable parameter estimates, but this issue can occasionally happen for certain models). Other arguments for the differential equations solver, i.e. for the solve function from DifferentialEquations.jl, can be similarly provided by keyword.","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"This result bgp is a BootResults struct, defined as follows:","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"struct BootResults\n    delayBases::Array{Float64}\n    diffusionBases::Array{Float64}\n    reactionBases::Array{Float64}\n    gp::GPBase\n    zvals::Array{Float64}\n    Xₛ::Array{Float64}\n    Xₛⁿ::Array{Float64}\n    bootₓ::Vector{Float64}\n    bootₜ::Vector{Float64}\n    T::Function\n    D::Function\n    D′::Function\n    R::Function\n    R′::Function\n    D_params\n    R_params\n    T_params\n    μ::Vector{Float64}\n    L::LowerTriangular{Float64}\n    gp_setup::GP_Setup\n    bootstrap_setup::Bootstrap_Setup\n    pde_setup::PDE_Setup\nend","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"The meaning for each field is self-explanatory. We also define a similar struct for computing the PDE solutions, plots, and AICs:","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"struct AllResults\n    pde_solutions::Array{Float64}\n    AIC::Vector{Float64}\n    bgp::Union{BootResults,BasisBootResults}\n    delayCIs\n    diffusionCIs\n    reactionCIs\n    delay_density::Figure\n    diffusion_density::Figure\n    reaction_density::Figure\n    delay_curve::Figure\n    diffusion_curve::Figure\n    reaction_curve::Figure\n    pde_plot::Figure\n    pde_error::Vector{Float64}\nend","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"We would typically use the constructor AllResults(x_pde, t_pde, u_pde, bgp) for constructing this struct. Since we have scaled the data, we also want to make use of additional keyword arguments to put the data back on the original scale. We thus create the AllResults struct for this data as:","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"delay_scales = [T_params2[1], T_params2[2] / t_scale]\ndiffusion_scales = D_params2[1] * x_scale^2 / t_scale\nreaction_scales = R_params2[2] / t_scale\nres = AllResults(x_pde, t_pde, u_bgp, bgp; delay_scales, diffusion_scales, reaction_scales, x_scale, t_scale, correct = true)","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"The correct = true keyword argument is used so that a small sample size correction is used for the computed AICs.","category":"page"},{"location":"tut.html#Looking-at-the-results","page":"Tutorial","title":"Looking at the results","text":"","category":"section"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"To finish the tutorial, we discuss how we could look at the results. The plots are all stored in this res variable we computed above. We do not show the plots here, but we would just look through the plots by writing in the REPL (the results may vary if you are running code alongside this tutorial due to the random number generation):","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"julia> res\n\nBootstrapping results\n\nNumber of bootstrap samples: 100\nPDE Error: (10.1, 14.5)\nAIC: (1.56e+03, 1.68e+03)\n\nα[1]: (-3.09, -0.854)\nα[2]: (0.133, 0.307)\nβ[1]: (117, 222)\nγ[1]: (0.0548, 0.0615)\n\n\njulia> res.pde_error\n2-element Vector{Float64}:\n 10.104350220097093\n 14.546789846145\n\njulia> res.delay_density\n\njulia> res.delay_curve\n\njulia> res.diffusion_density\n\njulia> res.diffusion_curve\n\njulia> res.reaction_density\n\njulia> res.reaction_curve","category":"page"},{"location":"tut.html","page":"Tutorial","title":"Tutorial","text":"These plots may not always be what is desired by the user. Customising these plots based on the bgp results may take some work, and ways that we could for example plot all these plots in the same figure (as we do in the paper), are given in the plotting functions in VandenHeuvel2022PaperCode/papercode.jl.","category":"page"},{"location":"paper.html#VandenHeuvel-et-al.-(2022)","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"","category":"section"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"This section briefly discusses our paper, and steps for reproducing the figures in the paper. The paper  can be found here ..., and the abstract of the paper is:","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"Parameter estimation for biological processes is often a difficult problem and depends significantly on the quality and quantity of avaiable data. We introduce a new framework which utilises Gaussian processes to discover the mechanisms underlying delay, diffusion, and reaction in a cell invasion process. Gaussian processes are leveraged with bootstrapping to provide uncertainty quantification for the mechanisms that drive the invasion process. Our framework is efficient and easily parallelisable, and can be applied to other problems. We illustrate our methods on a scratch assay experiment, demonstrating how simply we can explore different functional forms and develop and test hypotheses about underlying mechanisms, such as whether delay is present in the cell invasion process.","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"The scratch assay data from Jin et al. (2016) can be found in this GitHub repository in VandenHeuvel2022_PaperCode/data.","category":"page"},{"location":"paper.html#Paper-results","page":"VandenHeuvel et al. (2022)","title":"Paper results","text":"","category":"section"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"The main body of the paper is produced using the code in VandenHeuvel2022PaperCode/papercode.jl. Below, we list the sections that this script is broken into, along with descriptions of these sections:","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"Load the required packages","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"Here we simply load all the necessary packages.","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"Set some global parameters ","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"(Note that we also have a section called this in 7. below.) This section defines some parameters for plotting that are used in most of the sections. We also write:","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"LinearAlgebra.BLAS.set_num_threads(1)","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"This setting was used to remove issues relating to A \\ b giving StackOverflowError. See, for example, #43301 or #43242.","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"Read in the data from Jin et al. (2016)","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"Here we read in the data from Jin et al. (2016), scaling the data by hat x = 1000 and hat t = 24.","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"Figure X: Plotting the density data from Jin et al. (2016)","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"This code plots the data from Jin et al. (2016) and also plots a curve through the average of the experimental replicates at each point in sspace and time.","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"Figure X: Plotting the Gaussian processes fit to the data from Jin et al. (2016)","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"This section plots the Gaussian processes over the data from Jin et al. (2016), These Gaussian processes are fit using GaussianProcesses.jl.","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"Figure X: Plotting the space-time diagram for the Gaussian process","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"This section plots the same Gaussian processes, but now plots them on the (x t) place, colouring the points by the mean of the Gaussian process posterior at each point (x t).","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"Set some global parameters ","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"This section now defines the global parameters for the bootstrapping. The parameters for the PDE are defined first, and then the parameters for bootstrapping. We also remove the left-most points from the data from Jin et al. (2016) here.","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"Model fits","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"This section contains the actual code that gives the figures in the paper. There are five functions that we define first:","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"model_fits: This function fits, for a given dataset, a Fisher-Kolmogorov model (with and without delay), a Porous-Fisher model (with and without delay), and a delayed generalised Porous-FKPP model.\nplot_fisher_kolmogorov_delay: This function plots the results from a delayed Fisher-Kolmogorov model.\nplot_generalised_fkpp_delay: This function plots the results from a delayed generalised Porous-FKPP model.\nplot_pde_soln!: This function adds, to an existing figure, an axis for the PDE solutions for a given dataset.\nplot_pde_soln: For the six datasets, this function plots all of the PDE solutions from each dataset on the same figure.","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"After these functions are defined, we define parameters that scale each parameter for each function such that the scaled parameters that we have to estimate are all mathcal O(1). We based these parameter scales on the results from Jin et al. (2016) and Lagergren et al. (2020), or adjusted further based on issues we observed when fitting models. We then fit all the models, which takes a reasonably long time to complete. We then make all the plots.","category":"page"},{"location":"paper.html#Simulation-studies","page":"VandenHeuvel et al. (2022)","title":"Simulation studies","text":"","category":"section"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"We also present several simulation studies in the paper, all of which are given in VandenHeuvel2022PaperCode/simulationstudies.jl.","category":"page"},{"location":"paper.html#Simulation-study-I:-Fisher-Kolmogorov-Model,-10,000-cells-per-well","page":"VandenHeuvel et al. (2022)","title":"Simulation study I: Fisher-Kolmogorov Model, 10,000 cells per well","text":"","category":"section"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"In this study we fit some models to data simulated from the Fisher-Kolmogorov model","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"fracpartial upartial t = beta_1fracpartial^2upartial x^2 + gamma_1uleft(1-fracuKright)","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"Running all this code will produce the figures in the corresponding section of our paper.","category":"page"},{"location":"paper.html#Simulation-study-I:-Fisher-Kolmogorov-Model,-10,000-cells-per-well-2","page":"VandenHeuvel et al. (2022)","title":"Simulation study I: Fisher-Kolmogorov Model, 10,000 cells per well","text":"","category":"section"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"In this study we fit some models to data simulated from the Fisher-Kolmogorov model","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"fracpartial upartial t = beta_1fracpartial^2upartial x^2 + gamma_1uleft(1-fracuKright)","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"Running all this code will produce the figures in the corresponding section of our paper.","category":"page"},{"location":"paper.html#Simulation-study-II:-Fisher-Kolmogorov-Model-with-delay,-10,000-cells-per-well","page":"VandenHeuvel et al. (2022)","title":"Simulation study II: Fisher-Kolmogorov Model with delay, 10,000 cells per well","text":"","category":"section"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"In this study we fit some models to data simulated from the delayed Fisher-Kolmogorov model","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"fracpartial upartial t = frac11+exp(-alpha_1-alpha_2t)leftbeta_1fracpartial^2upartial x^2 + gamma_1uleft(1-fracuKright)right","category":"page"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"Running all this code will produce the figures in the corresponding section of our paper.","category":"page"},{"location":"paper.html#Simulation-study-III:-Fisher-Kolmogorov-model,-10,000-cells-per-well,-basis-function-approach","page":"VandenHeuvel et al. (2022)","title":"Simulation study III: Fisher Kolmogorov model, 10,000 cells per well, basis function approach","text":"","category":"section"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"This study fits the same model as in study I, but using the basis function approach. Running all this code will produce the figures in the corresponding section of our paper.","category":"page"},{"location":"paper.html#Simulation-study-IV:-Data-thresholding-on-the-Fisher-Kolmogorov-model-of-Study-I","page":"VandenHeuvel et al. (2022)","title":"Simulation study IV: Data thresholding on the Fisher-Kolmogorov model of Study I","text":"","category":"section"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"This study considers the effects of data thresholding on the model in the first study. This study is done by simply looping over many tolerance values. Running all this code will produce the figures in the corresponding section of our paper.","category":"page"},{"location":"paper.html#Simulation-study-V:-Data-thresholding-on-the-Fisher-Kolmogorov-model-of-Study-II","page":"VandenHeuvel et al. (2022)","title":"Simulation study V: Data thresholding on the Fisher-Kolmogorov model of Study II","text":"","category":"section"},{"location":"paper.html","page":"VandenHeuvel et al. (2022)","title":"VandenHeuvel et al. (2022)","text":"This study considers the effects of data thresholding on the model in the second study. This study is done by simply looping over many tolerance values. Running all this code will produce the figures in the corresponding section of our paper.","category":"page"}]
}
